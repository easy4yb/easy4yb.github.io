{"meta":{"title":"Blog of yb","subtitle":"学如逆水行舟","description":"Huster","author":"袁斌","url":"https://ez4yb.cn","root":"/"},"pages":[{"title":"标签","date":"2021-03-28T07:35:58.943Z","updated":"2021-03-28T07:35:58.943Z","comments":true,"path":"tags/index.html","permalink":"https://ez4yb.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重排和重绘","slug":"重排和重绘","date":"2021-03-18T19:24:47.000Z","updated":"2021-03-18T19:30:09.331Z","comments":true,"path":"2021/03/19/重排和重绘/","link":"","permalink":"https://ez4yb.cn/2021/03/19/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"施工中—","text":"施工中—","categories":[],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://ez4yb.cn/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"}],"author":"袁斌"},{"title":"JavaScript原型与继承总结","slug":"JavaScript原型和继承","date":"2021-03-17T02:51:18.000Z","updated":"2021-03-31T10:56:11.953Z","comments":true,"path":"2021/03/17/JavaScript原型和继承/","link":"","permalink":"https://ez4yb.cn/2021/03/17/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/","excerpt":"&emsp;&emsp;每个JavaScript对象在创建的时候，就会有与之关联的另一个对象，这个对象就叫做原型，每个对象都会从“原型”继承属性。","text":"&emsp;&emsp;每个JavaScript对象在创建的时候，就会有与之关联的另一个对象，这个对象就叫做原型，每个对象都会从“原型”继承属性。 原型与原型链&emsp;&emsp;初看文字描述的时候我觉得原型链很怪异，不好理解，在结合了代码和图示后，一切都豁然开朗。那么就先来一段可以反应原型特性的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class People&#123; //人类有一个属性名字 constructor(name)&#123; this.name = name; &#125; //人类有一个方法叫吃 eat()&#123; console.log(`$&#123;this.name&#125; eat something`); &#125;&#125;//学生是人类，继承人类的属性“名字”以及方法“吃”class Student extends People&#123; //学生有两个属性，姓名和学号 constructor(name, number)&#123; super(name); this.number = number; &#125; //学生有一个方法叫自我介绍 selfIntro()&#123; console.log(`姓名$&#123;this.name&#125; 学号$&#123;this.number&#125;`); &#125;&#125;//老师是人类，继承人类的属性“名字”以及方法“吃”class Teacher extends People&#123; //老师有两个属性，名字和科目 constructor(name, major)&#123; super(name); this.major = major; &#125; //老师有一个方法叫讲授 teach()&#123; console.log(`$&#123;this.name&#125;教$&#123;this.major&#125;`); &#125;&#125;//Student的实例const me = new Student(&#x27;袁斌&#x27;,&#x27;3&#x27;);console.log(me.name);//袁斌console.log(me.number);//3me.selfIntro();//姓名袁斌 学号3me.eat();//袁斌 eat something//teacher的实例const missMa = new Teacher(&#x27;马老师&#x27;, &#x27;DSP&#x27;) console.log(missMa.name);//马老师console.log(missMa.major);//DSPmissMa.teach();//马老师教DSPmissMa.eat();//马老师 eat something &emsp;&emsp;如上可见，me是Student的实例对象，同时获得了Student的方法以及Student的父类People的方法，那么这些方法是如何获取的呢。在以上代码的基础上，我们在浏览器输入me查看： &emsp;&emsp;可以看出，me是一个Student对象，它有属性name、number，以及一个__proto__属性，该___proto__属性中有一个selfIntro方法，一个__proto__属性，**以及一个constructor属性指向Class Student**，即Student构造函数。我们把这个__proto__属性写作me.__proto__。再输入Student.prototype查看： &emsp;&emsp;可以很清晰的看到，它和上面的me.__proto__内容相同。同时，它的__proto__有一个constructor属性指向 Class People，结合上面的黑字部分，我们可以判断出，Student.prototype是people的一个实例。我们可以进一步验证以上推断： &emsp;&emsp;由此我们可以根据这些关系画出一个一目了然的图示（为了简化省略了Teacher）： &emsp;&emsp;这便是JavaScript的原型链，当我们调用一个对象的方法时，依次查找本对象的属性，如果没有，就沿着__proto__属性向上查找，直到找到同名方法。 继承类继承&emsp;&emsp;最简洁的继承方式莫过于前文使用过的，通过Class和extends实现继承，子类extends父类，用super调用父类构造函数即可实现继承。需要注意的是： 函数声明可以提升，而类定义不能； 函数受函数作用域限制，而类受块作用域限制 创建一个对象实例时，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象。调回类构造函数时如果忘了使用new则会抛出错误。 Class是ES6新增的语法，而在这之前，JavaScript主要通过原型和构造函数实现继承，事实上，类继承背后使用的仍然是原型和构造函数的概念。 原型链继承12345678910111213141516171819//原型链继承function SuperType()&#123; this.name = &#x27;袁斌&#x27; this.arr = [1, 2];&#125;SuperType.prototype.getName = function()&#123; console.log(this.name);&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType();let sub1 = new SubType();sub1.getName();//袁斌 &emsp;&emsp;它存在两个问题： 原型中包含的引用会在所有实例间共享，如下所示 123456789console.log(sub1.arr);//[1, 2]let sub2 = new SubType();sub2.name = &#x27;某某&#x27;;sub2.arr.push(3); sub1.getName();//袁斌sub2.getName();//某某console.log(sub2.arr);//[1, 2, 3]console.log(sub2.__proto__.name);//袁斌 注意：name属性看似没有共享是因为sub2.name = &#39;某某&#39;是为sub2添加了name值，并不是修改了原型链上的name。代码最后一行可见原型上的name值并没有改变。 子类型在实例化时不能给父类型的构造函数传参。 因此，原型链继承基本不会被单独使用。 盗用构造函数12345678910111213141516//盗用构造函数function SuperType()&#123; this.arr = [1, 2];&#125;function SubType()&#123; SuperType.call(this);&#125;let sub1 = new SubType();let sub2 = new SubType();sub2.arr.push(3);console.log(sub1.arr);//[1, 2]console.log(sub2.arr);//[1, 2, 3] 本质是在新的SubType对象中运行了SuperType()中的所有初始化方法，因而每个实例都会有自己的arr属性。 同时也允许在子类构造函数中向父类构造函数传参： 12345678910111213function SuperType(name)&#123; this.name = name;&#125;function SubType(name)&#123; SuperType.call(this, name); this.age = 21;&#125;let sub1 = new SubType(&#x27;袁斌&#x27;);console.log(sub1.name);//袁斌console.log(sub1.age);//21 &emsp;&emsp;但是它也存在一个问题：函数不能重用，每次创建实习都会创建一遍方法。 因此，盗用构造函数基本也不能单独使用。 组合继承12345678910111213141516171819202122232425262728293031323334//组合继承function SuperType(name)&#123; this.name = name; this.arr = [1, 2];&#125;SuperType.prototype.getName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.getAge = function()&#123; console.log(this.age);&#125;let sub1 = new SubType(&#x27;袁斌&#x27;, 21);let sub2 = new SubType(&#x27;某某&#x27;, 1);sub1.arr.push(3);console.log(sub1.arr);//[1, 2, 3]console.log(sub2.arr);//[1, 2]sub1.getName();//袁斌sub2.getName();//某某sub1.getAge();//21sub2.getAge();//1 &emsp;&emsp;可以看出，组合继承使用原型链继承原型上的属性和方法，而通过盗用构造函数来继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。 原型式继承1234567891011121314151617//原型式继承function object(o)&#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;let a = &#123; name: &#x27;袁斌&#x27;, arr: [1, 2]&#125;let b = object(a);console.log(b.__proto__);//&#123; name: &#x27;袁斌&#x27;, arr: [ 1, 2 ] &#125;b.arr.push(3);console.log(a.arr);//[1, 2, 3] &emsp;&emsp;等同于ES5中的Object.create()方法，本质上是对传入的对象执行了一次浅复制，与原型链继承存在同样的问题。它适合“不需要单独创建构造函数，但仍然需要在对象间共享信息”的场合。 寄生式继承12345678//寄生式继承function createObj(o)&#123; let clone = object(o);//即上面的原型式继承方法，也可用Object.create()代替 clone.sayHi = function()&#123; console.log(&#x27;Hi&#x27;); &#125;; return clone;&#125; &emsp;&emsp;盗用构造函数类似，它也会导致函数难以重用。 寄生组合式继承123456789101112131415161718192021222324252627282930313233343536373839//寄生组合式继承function inheritPrototype(subType, superType)&#123; let prototype = Object.create(superType.prototype);//创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype;//赋值对象&#125;function SuperType(name)&#123; this.name = name; this.arr = [1, 2];&#125;SuperType.prototype.getName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.getAge = function()&#123; console.log(this.age);&#125;let sub1 = new SubType(&#x27;袁斌&#x27;, 21);let sub2 = new SubType(&#x27;某某&#x27;, 1);sub1.arr.push(3); console.log(sub1.arr);//[1, 2, 3]console.log(sub2.arr);//[1, 2]sub1.getName();//袁斌sub2.getName();//某某sub1.getAge();//21sub2.getAge();//1 &emsp;&emsp;可见寄生组合式继承仅仅是把组合式继承中的SubType.prototype = new SuperType()改为以下过程：先创建一个父类原型的副本，然后给返回的prototype设置construtor属性，解决组合式继承由于重写原型导致constructor丢失的问题，然后将新创建的对象赋给子类型的原型。这样相比组合式继承，少调用了一个父类构造函数，避免了SubType.prototype中不必要的属性。而且，原型链仍保持不变，还能正常使用instanceOf和isPrototypeOf()。综上所述，“寄生组合式继承是引用类型继承的最佳模式“。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"}],"author":"袁斌"},{"title":"JavaScript深拷贝","slug":"JavaScript深拷贝","date":"2021-03-15T09:14:06.000Z","updated":"2021-03-31T10:56:02.915Z","comments":true,"path":"2021/03/15/JavaScript深拷贝/","link":"","permalink":"https://ez4yb.cn/2021/03/15/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"JavaScript存在值类型和引用类型的区分，当我们想根据一个已存在的引用类型复制出一个新的引用类型时，我们就需要通过深拷贝来实现。","text":"JavaScript存在值类型和引用类型的区分，当我们想根据一个已存在的引用类型复制出一个新的引用类型时，我们就需要通过深拷贝来实现。 类型区分对一个值类型进行复制后，复制值与之前的值没有关系，二者可以单独修改 1234let a = 2;let b = a;b = 4;console.log(b) //4 对一个引用类型进行复制，实际上是使新对象的指针指向原对象指针所指向的位置。所以对新对象的属性进行修改时，会通过指针去修改新旧对象共同指向的内容。 12345678910111213141516const a = &#123; age: 20, name: &#x27;xxx&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Wuhan&#x27; &#125;&#125;const b = a;b.age = 21;b.address.city = &#x27;Jiangxi&#x27;console.log(a.age); // 21console.log(a.address.city); //Jiangxi 由此可见，通过这种方式复制一个引用类型，并没有创建一个新对象，当我们并不想修改原先的引用类型值的时候，就需要进行“深拷贝”，如图所示： 深拷贝方法一 ：递归遍历12345678910111213141516171819202122232425262728293031323334353637383940414243function deepClone(obj)&#123; if(obj == null || typeof obj !== &#x27;object&#x27;)&#123; return obj; &#125; let result; //初始化返回结果 if(result instanceof Array)&#123; result = []; &#125;else&#123; result = &#123;&#125;; &#125; for(const key in obj)&#123; //保证key不是原型的值 if (obj.hasOwnProperty(key))&#123; //递归调用 result[key] = deepClone(obj[key]); &#125; &#125; return result;&#125;const a = &#123; age: 20, name: &#x27;xxx&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Wuhan&#x27; &#125;&#125;const b = deepClone(a);b.age = 21;b.name = &#x27;yyy&#x27;;b.address.city = &#x27;Xiangyang&#x27;;console.log(a); //&#123; age: 20, name: &#x27;xxx&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Wuhan&#x27; &#125; &#125;console.log(b); //&#123; age: 21, name: &#x27;yyy&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Xiangyang&#x27; &#125;&#125; 可见执行深拷贝后成功达到了目的。 方法二：JSON.parse(JSON.stringify(obj))利用JSON.stringify 将对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)对象。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"}],"author":"袁斌"},{"title":"圣杯布局和双飞翼布局","slug":"圣杯布局和双飞翼布局","date":"2021-03-11T08:11:18.000Z","updated":"2021-03-30T00:13:13.870Z","comments":true,"path":"2021/03/11/圣杯布局和双飞翼布局/","link":"","permalink":"https://ez4yb.cn/2021/03/11/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"pc网页经典布局","text":"pc网页经典布局 布局特点 三栏布局，中间一栏最先渲染和加载 两侧内容固定，中间内容随宽度自适应 实现方法 使用float布局 两侧使用margin负值，以便和中间内容重叠 防止中间内容被两侧覆盖，圣杯布局用padding，双飞翼布局用margin 圣杯布局1234567&lt;div id = &quot;header&quot;&gt;header&lt;/div&gt;&lt;div id = &quot;container&quot; class = &quot;clearfix&quot;&gt; &lt;div id = &quot;center&quot; class = &quot;column&quot;&gt;center&lt;/div&gt; &lt;div id = &quot;left&quot; class = &quot;column&quot;&gt;left&lt;/div&gt; &lt;div id = &quot;right&quot; class = &quot;column&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div id = &quot;footer&quot;&gt;footer&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#container .column&#123; float: left; &#125; #header &#123; text-align: center; background-color: #f1f1f1; &#125; /* 根据left和right的宽度设置padding，给出显示两边内容的空间 */ #container&#123; padding-left: 200px; padding-right: 150px; &#125; #center &#123; background-color: #ccc; width: 100% ; &#125; #left &#123; background-color: yellow; width: 200px; /* 通过margin-left负值使left和center横向重合 */ margin-left: -100%; /* 通过relative定位，设置right把自身向左推200px */ position: relative; right: 200px; &#125; #right &#123; background-color: red; width: 150px; /* 设置margin-right负值，使自身宽度在外界看来为0，不再需要换行，自动移至center右侧 */ margin-right: -150px; &#125; #footer &#123; text-align: center; background-color: #f1f1f1; &#125; /* 通过clearfix使footer被撑到container下方 */ .clearfix::after&#123; display: block; clear: both; content: &#x27;&#x27;; &#125; 效果： 双飞翼布局1234567891011&lt;div id=&quot;main&quot; class=&quot;col&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt; this is main &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;left&quot; class=&quot;col&quot;&gt; this is left&lt;/div&gt;&lt;div id=&quot;right&quot; class=&quot;col&quot;&gt; this is right&lt;/div&gt; 12345678910111213141516171819202122232425.col &#123; float: left; &#125; #main &#123; width: 100%; height: 200px; background-color: #ccc; &#125; #main-wrap &#123; margin: 0 190px 0 190px; &#125; #left &#123; width: 190px; height: 200px; background-color: #0000FF; margin-left: -100%; &#125; #right &#123; width: 190px; height: 200px; background-color: #FF0000; margin-left: -190px; &#125; 效果：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"行内元素、块级元素","slug":"行内元素、块级元素","date":"2021-03-06T16:35:44.000Z","updated":"2021-03-18T17:43:01.220Z","comments":true,"path":"2021/03/07/行内元素、块级元素/","link":"","permalink":"https://ez4yb.cn/2021/03/07/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/","excerpt":"简单总结行内元素、块级元素、行内块元素的异同","text":"简单总结行内元素、块级元素、行内块元素的异同 块级元素： 独占一行 设置width和height有效。（默认width是父元素的100%，height取决于内容的height） 设置margin，上下左右有效 设置padding，上下左右有效 常见块级元素：div、h1~6、p、ul 行内元素： 不会独占一行 设置width和height无效。（默认width取决于内容的width，默认height取决于内容的height） 设置margin，左右有效，上下无效 设置padding，上下左右都有效，但不建议设置上下，易导致对上下元素的覆盖。 常见行内元素：a 、span、 em、 i、 b、 strong 行内块元素 不会独占一行 设置width和height有效 设置margin，上下左右有效 设置padding，上下左右有效 使用display属性可以将三者互相转换： display: inline转换为行内元素 display: block转换为块级元素 display: inline-block转换为行内块级元素 display: none元素不显示","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://ez4yb.cn/tags/html/"}],"author":"袁斌"},{"title":"CSS页面布局总结","slug":"CSS页面布局总结","date":"2021-03-05T14:04:29.000Z","updated":"2021-03-31T10:55:34.853Z","comments":true,"path":"2021/03/05/CSS页面布局总结/","link":"","permalink":"https://ez4yb.cn/2021/03/05/CSS%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/","excerpt":"CSS页面布局主要通过两种方式实现，Float和Flexbox。","text":"CSS页面布局主要通过两种方式实现，Float和Flexbox。 Float浮动布局可以使元素脱离正常流，块级元素会忽略浮动元素，而行内元素会环绕浮动元素。下面是一个简单的例子： 123456&lt;div class = &#x27;border&#x27;&gt; &lt;div class = &#x27;float_lightcoral&#x27;&gt;&lt;/div&gt; &lt;div class = &#x27;normal_red&#x27;&gt;&lt;/div&gt; &lt;div class = &#x27;float_blue&#x27;&gt;&lt;/div&gt; 我的名字叫吉良吉影，33岁。住在杜王町东北部的别墅区一带，未婚。我在龟友连锁店服务。每天都要加班到晚上8点才能回家。我不抽烟，酒仅止于浅尝。晚上11点睡，每天要睡足8个小时。睡前，我一定喝一杯温牛奶，然后做20分钟的放松体操，上了床，马上熟睡。一觉到天亮，决不把疲劳和压力，留到第二天。医生都说我很正常. &lt;/div&gt; 12345678910111213141516171819202122232425.border&#123; border:1px black solid; width: 500px; height: 200px; &#125; .float_lightcoral&#123; float: left; width: 100px; height: 50px; background-color: lightcoral; &#125; .float_blue&#123; float: left; width: 100px; height: 50px; background-color: blue; &#125; .normal_red&#123; width: 160px; height: 50px; background-color: red; &#125; 效果： 由图可见，红色块级元素忽略了浮动元素，排在左上角，但是一部分被粉色浮动元素遮挡。而行内元素，即文字部分，受到蓝色浮动元素的影响，环绕其展开。 float可设置的值 left：元素向左浮动 right：元素向右浮动 none：默认值，不浮动 inherit：从父元素继承浮动值 清除浮动因为浮动元素不能撑开包含块，有时需要清楚浮动以使元素正常显示。其方法主要有两种： BFC如前所述 clearfix其原理是给元素尾部设置一个内容为空的伪类，并清除浮动，以撑开包含块。下面是个简单的例子： 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; 123456789101112131415161718192021222324.container &#123; width: 500px; background-color: black;&#125;.left &#123; width: 200px; height: 300px; background-color: red; float: left;&#125;.right &#123; width: 200px; height: 200px; background-color: green; float: right;&#125;.footer &#123; width: 400px; height: 50px; background-color: blue;&#125; 效果如图： 由图可见，为了使布局正常显示，footer应该被撑开，排列在最下面。 遂给container添加clearfix： 12345&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; 12345.container.clearfix::after&#123; clear: both; content: &#x27;&#x27;; display: block;&#125; 效果： Flexbox","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"CSS定位总结","slug":"CSS定位总结","date":"2021-03-02T17:41:32.000Z","updated":"2021-03-31T10:55:26.758Z","comments":true,"path":"2021/03/03/CSS定位总结/","link":"","permalink":"https://ez4yb.cn/2021/03/03/CSS%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/","excerpt":"CSS的定位方式由position元素的设置决定","text":"CSS的定位方式由position元素的设置决定 position属性可以设定的值有： static relative absolute fixed sticky staticstatic是position属性的默认值，浏览器会按照源码的顺序，决定每个元素的位置，这称为“正常流”(Normal flow)。 relative表示元素相对于默认位置(即static)偏移，可以由left、right、top、bottom控制偏移量 absolute表示元素相对于父元素偏移，且该父元素不能是static定位，否则定位基点就会变成整个网页的根元素html。和relative类似，absolute定位也需用left、right、top、bottom控制偏移量 absolute定位的元素会被“正常流”忽略，即在正常流中，该元素所占空间为零 fixed表示元素相对于浏览器窗口绝对定位 stickysticky定位可以使元素呈现“动态固定”的效果，当父元素开始脱离视窗时，只要与sticky元素的距离达到生效门槛，元素定位从relative自动切换为fixed；等父元素完全脱离视窗时，元素定位从fixed自动切换为relative","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"BFC总结","slug":"BFC总结","date":"2021-03-01T15:12:44.000Z","updated":"2021-03-31T10:54:55.627Z","comments":true,"path":"2021/03/01/BFC总结/","link":"","permalink":"https://ez4yb.cn/2021/03/01/BFC%E6%80%BB%E7%BB%93/","excerpt":"BFC的理解与应用","text":"BFC的理解与应用 BFC简介BFC（Block format context， 块级格式化上下文)，它是页面中一块独立的渲染区域，内部元素的渲染不会影响边界外部的元素。 触发BFC只要元素满足下列任一条件即可触发BFC： body根元素 float是none以外的值 position是absolute或fixed overflow是visible以外的值(hidden, auto, scroll) display是inline-block, flex或table-cells BFC应用1.通过把相邻元素放在不同BFC中，可以清除外边距折叠 2.清楚浮动","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"CSS盒模型总结","slug":"CSS盒模型总结","date":"2021-02-27T13:44:49.000Z","updated":"2021-03-11T07:51:00.657Z","comments":true,"path":"2021/02/27/CSS盒模型总结/","link":"","permalink":"https://ez4yb.cn/2021/02/27/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"对盒子模型做个简单概括","text":"对盒子模型做个简单概括 盒模型类别 标准盒模型 由四个部分组成： content box: 用来显示内容的区域，通过”width”和”height”设置大小 padding box: 内边距 border box: 边框 margin box: 外边距 替代(IE)盒模型 如图可以很直观的看出，替代盒模型相比IE盒模型的区别在于它的width和height等于content + padding + border的宽度。 可以通过设置box-sizing来设置盒子的类型（默认为标准盒模型）: box-sizing: content-box：标准盒模型 box-sizing: border-box： IE盒模型 padding可以整体设置大小，也可以分别各个方向分别设置，如： padding-top: 30px; padding-right: 20px; padding-bottom: 40px; padding-left: 100px; padding:30px 20px 40px 100px; 如果写了四个值，则顺序为：上 右 下 左； 如果写了三个值，则顺序为：上 右 下。自动设置左 = 右。 如果只写了两个值，如padding: 30px 40px，则等价于padding: 30px 40px 30px 40px; margin属性设置和padding类似 borderborder的属性设置顺序为：粗细 类型 颜色：如 border: 1px ridge red 通过border画三角形 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type = &quot;text/css&quot;&gt; div&#123; width: 0px; height: 0px; border: 50px solid; border-color: red white white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： margin纵向重叠 相邻元素的margin-top和margin-bottom会发生重叠 空白内容也会重叠 如： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type = &quot;text/css&quot;&gt; p &#123; font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;P&gt;AAA&lt;/P&gt; &lt;P&gt;&lt;/P&gt; &lt;P&gt;&lt;/P&gt; &lt;P&gt;CCC&lt;/P&gt;&lt;/body&gt;&lt;/html&gt; 效果： margin负值 margin-top和margin-left负值，元素向上，向左移动 margin-right负值，右侧元素左移，自身不受影响 margin-bottom负值，下方元素上移，自身不受影响","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"JavaScript实现二叉搜索树","slug":"JavaScript实现二叉搜索树","date":"2021-02-22T11:01:50.000Z","updated":"2021-03-18T18:36:08.541Z","comments":true,"path":"2021/02/22/JavaScript实现二叉搜索树/","link":"","permalink":"https://ez4yb.cn/2021/02/22/JavaScript%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"使用JavaScript实现二叉搜索树(施工中)","text":"使用JavaScript实现二叉搜索树(施工中) 二叉搜索树一个非空的二叉搜索树（BST，Binary Search Tree）满足以下性质： 非空左子树的所有键值均小于其根节点的键值 非空右子树的所有键值均大于其根节点的键值 左，右子树本身也是二叉搜索树 因此，树中相对较小的值总保存在左节点上，相对较大的值总保存在右节点上。这样一来，在二叉搜索树中查找一个值，其实是模仿了二分查找法，可以很大程度地提升效率。 二叉搜索树的操作 insert(key)：向树中插入一个新的键。 search(key)：在书中查找一个键，存在返回true，不存在则返回false。 inOrderTraversal()： 中序遍历所有节点 preOrderTraversal()： 先序遍历所有节点 postOrderTraversal()： 后序遍历所有节点 min()： 返回树中最小的键值 max()： 返回树中最大的键值 remove(key)： 从树中移除某个键 二叉搜索树的实现1","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现哈希表","slug":"JavaScript实现哈希表","date":"2021-02-19T11:14:37.000Z","updated":"2021-03-30T00:06:49.163Z","comments":true,"path":"2021/02/19/JavaScript实现哈希表/","link":"","permalink":"https://ez4yb.cn/2021/02/19/JavaScript%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"使用JavaScript通过链地址法实现哈希表","text":"使用JavaScript通过链地址法实现哈希表 哈希表&emsp;&emsp;哈希表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。&emsp;&emsp;给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。 哈希表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164function HashTable()&#123; //属性 this.storage = []; this.count = 0; this.limit = 7; //方法 //哈希函数 HashTable.prototype.hasFunc = function(str, size)&#123; let hashcode = 0; for(let i = 0; i &lt; str.length; i++)&#123; hashcode = 37 * hashcode + str.charCodeAt(i) &#125; let index = hashcode % size; return index; &#125; //判断是否为质数 HashTable.prototype.isPrime = function(num)&#123; if(num &lt;= 1)&#123; return false; &#125;else&#123; for(let i = 2; i &lt;= Math.sqrt(num); i++)&#123; if(num % i == 0)&#123; return false; &#125; &#125; return true; &#125; &#125; //插入与修改 HashTable.prototype.put = function(key, value)&#123; //根据key获取index let index = this.hasFunc(key, this.limit); //根据index获取bucket let bucket = this.storage[index]; //判断bucket是否为空 if(!bucket)&#123; bucket = []; this.storage[index] = bucket; &#125; //判断是否是修改数据 for(let i = 0; i &lt; bucket.length; i++)&#123; let tuple = bucket[i]; if(tuple[0] == key)&#123; tuple[1] = value; return; &#125; &#125; //执行添加操作 bucket.push([key, value]); this.count++; //判断是否需要扩容 if(this.count &gt; 0.75 * this.limit)&#123; let newLimit = this.limit * 2; while(!this.isPrime(newLimit))&#123; newLimit++; &#125; this.resize(newLimit); &#125; &#125; //获取 HashTable.prototype.get = function(key)&#123; //根据key获取index let index = this.hasFunc(key, this.limit); //根据index获取bucket let bucket = this.storage[index]; //判断bucket是否为空 if(!bucket)&#123; return null; &#125; //查找key for(let i = 0; i &lt; bucket.length; i++)&#123; let tuple = bucket[i]; if(tuple[0] == key)&#123; return tuple[1]; &#125; &#125; return null; &#125; //删除 HashTable.prototype.remove = function(key)&#123; //根据key获取index let index = this.hasFunc(key, this.limit); //根据index获取bucket let bucket = this.storage[index]; //判断bucket是否为空 if(!bucket)&#123; return false; &#125; //查找key并删除 for(let i = 0; i &lt; bucket.length; i++)&#123; let tuple = bucket[i]; if(tuple[0] == key)&#123; bucket.splice(i, 1); this.count--; //判断是否需要缩小容量 if(this.count &gt; 7 &amp;&amp; this.count &lt; 0.25 * this.limit)&#123; let newLimit = Math.floor(this.limit/2); while(!this.isPrime(newLimit))&#123; newLimit++; &#125; this.resize(newLimit); &#125; &#125; &#125; return null; &#125; //判断是否为空 HashTable.prototype.isEmpty = function () &#123; return this.count == 0; &#125; //获取元素个数 HashTable.prototype.size = function()&#123; return this.count; &#125; //扩容 HashTable.prototype.resize = function (newLimit)&#123; //保留旧的数组内容 let oldStorage = this.storage; //重置所有属性 this.storage = []; this.count = 0; this.limit = newLimit; //遍历旧数组 for(let i = 0; i &lt; oldStorage.length; i++)&#123; let bucket = oldStorage[i]; if(bucket == null)&#123; continue; &#125;else &#123; for(let j = 0; j &lt; bucket.length; j++)&#123; let tuple = bucket[i]; this.put(tuple[0], tuple[1]); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现集合","slug":"JavaScript实现集合","date":"2021-02-17T00:29:44.000Z","updated":"2021-03-31T10:54:14.247Z","comments":true,"path":"2021/02/17/JavaScript实现集合/","link":"","permalink":"https://ez4yb.cn/2021/02/17/JavaScript%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/","excerpt":"虽然es6已经包括了Set类，可以直接使用，但为了了解集合的内部实现机制，我尝试自己来封装一下这个Set类。","text":"虽然es6已经包括了Set类，可以直接使用，但为了了解集合的内部实现机制，我尝试自己来封装一下这个Set类。 集合的特点 集合通常是由一组无序的不能重复的元素构成 可以看作一种特殊的数组，特殊在于里面的元素没有顺序也不能重复 集合常用操作 add(value): 向集合中添加一个新的项 remove(value): 从集合中移除一个值 has(value): 判断集合中是否存在该值 clear(): 移除集合中的所有项 size(): 返回集合所包含元素的数量 values(): 返回一个包含集合中所有值的数组 集合的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Set()&#123; //属性 this.items = &#123;&#125;; //方法: //向集合添加一个新的项 Set.prototype.add = function(value)&#123; //判断集合中是否已存在该元素 if(this.has(value))&#123; return false; &#125;else&#123; this.items[value] = value; return true; &#125; &#125; //从集合中移除一个值 Set.prototype.remove = function()&#123; if(this.has(value))&#123; return false; &#125;else&#123; delete this.items[value]; return true; &#125; &#125; //如果值在集合中，返回true，否则返回false Set.prototype.has = function(value)&#123; return this.items.hasOwnProperty(value); &#125; //移除集合中的所有项 Set.prototype.clear = function()&#123; this.items = &#123;&#125;; &#125; //返回集合中所包含元素的数量 Set.prototype.size = function()&#123; return Object.keys(this.items).length; &#125; //返回一个包含集合中所有值的数组 Set.prototype.values = function () &#123; return Object.keys(this.items); &#125;&#125; 集合间的操作 求两集合并集 12345678910111213141516171819Set.prototype.union(otherSet)&#123; //创建一个新的Set实例储存并集结果 let unionSet = new Set(); //取出原集合的值 let Values = this.values(); //把取出的值插入unionSet for(let i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]); &#125; //取出另一集合的值 values = otherset.values(); for(let i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]; &#125; return unionset;&#125; 求两集合交集 12345678910111213Set.prototype.intersection = function(otherSet)&#123; let intersectionSet = new Set(); let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; //如果该值也存在于另一个集合，则存入 if(otherSet.has(values[i]))&#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet;&#125; 求两集合差集 12345678910111213Set.prototype.difference = function(otherSet)&#123; let differeneSet = new Set(); let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; //如果该值不存在于另一个集合，则存入 if(otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return difference; &#125; 子集判断 1234567891011Set.prototype.subset = function(otherset)&#123; let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; if(!otherset.has(values[i]))&#123; return false; &#125; return true; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现链表","slug":"JavaScript实现链表","date":"2021-02-14T23:30:12.000Z","updated":"2021-03-31T10:54:05.449Z","comments":true,"path":"2021/02/15/JavaScript实现链表/","link":"","permalink":"https://ez4yb.cn/2021/02/15/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/","excerpt":"使用JavaScript实现链表以及双向链表","text":"使用JavaScript实现链表以及双向链表 链表结构​ 链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向后一个节点。如图： 链表对比数组 优点 链表内存空间不是必须是连续的，可以充分利用计算机内存空间。 链表不必再创建时就设定大小，并且大小可以无限的延申下去。 链表在插入和删除数据时，时间复杂度可以达到O(1)，效率相对数组高很多 缺点 链表访问任何一个位置的元素时，都学要从头开始访问，无法通过下标直接访问元素 链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//封装链表function LinkedList()&#123; //封装Node类作为节点 function Node(data)&#123; this.data = data; this.next = null; &#125; //属性 this.length = 0; this.head = null; //方法 //向链表尾部添加一个新的项 LinkedList.prototype.apend = function(data)&#123; let newNode = new Node(data); if(this.head == null)&#123; this.head = newNode; &#125;else&#123; let current = this.head; while(current.next)&#123; current = current.next; &#125; current.next = newNode; &#125; this.length++; &#125; //向链表的特定位置插入一个新的项 LinkedList.prototype.insert = function (positon, data) &#123; //越界判断 if(positon &lt; 0 || positon &gt; this.length)&#123; return false; &#125;else&#123; let newNode = new Node(data); //判断链表是否为空 if(!this.head)&#123; this.head = newNode; &#125;else&#123; let current = this.head; let previous = null; if(positon == 0)&#123; newNode.next = current; this.head = newNode; &#125;else&#123; let i = 0; while(i++ &lt; positon)&#123; previous = current; current = current.next; &#125; newNode.next = current; previous.next = newNode; &#125; &#125; &#125; this.length++; &#125; //获取对应位置的元素 LinkedList.prototype.get = function (position) &#123; if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125; let current = this.head; for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; return current; &#125; //返回元素在列表中的索引，如果链表中没有该元素则返回-1 LinkedList.prototype.indexOf = function(data)&#123; let current = this.head; let index = 1; while(current)&#123; if(current.data == data)&#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125; //修改某个位置的元素 LinkedList.prototype.update = function(position, data)&#123; let current = this.get(position); current.data = data; &#125; //从链表的特定位置移除一项 LinkedList.prototype.removeAt = function(position)&#123; if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125; let previous = null; let current = this.head; let i = 1; if(position == 1)&#123; this.head = current.next; &#125;else&#123; while(i++ &lt; position)&#123; previous = current; current = current.next; &#125; previous.next = current.next; current.next = previous.next; &#125; this.length--; &#125; //从链表中移除一项 LinkedList.prototype.remove = function (data) &#123; this.removeAt(this.indexOf(data)); this.length--; &#125; //如果链表中不包含任何元素，返回true，否则返回false LinkedList.prototype.isEmpty = function()&#123; if(this.length)&#123; return false; &#125;else&#123; return true; &#125; &#125; //返回链表包含的元素个数 LinkedList.prototype.size = function()&#123; return this.length; &#125; //由于链表项使用了Node类，就需要重写继承自Javascript对象默认的toString方法，让其只输出元素的值 LinkedList.prototype.toString = function () &#123; let current = this.head; var listString = &quot;&quot;; while(current)&#123; listString += &#x27; &#x27; + current.data; current = current.next this.length++; &#125; return listString; &#125;&#125; 双向链表 单向链表 只能从头遍历到尾或者从尾遍历到头 可以轻松地到达下一个节点，但是回到前一个节点是很难地 双向链表 既可以从头遍历到尾，也可从尾遍历到头 一个节点既有向前遍历的节点，也有向后遍历的节点 每次加入或删除节点时，需要处理四个节点的引用，实现起来更加复杂 相比于单向链表，占用内存空间更大 图示： 双向链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180function DoublyLinkedList()&#123; //构建Node类 function Node(element)&#123; this.element = element; this.prev = null; this.next = null; &#125; this.head = null; this.tail = null; this.length = 0 //向链表尾部添加一个新的项 DoublyLinkedList.prototype.apend = function(element)&#123; let newNode = new Node(element); if(this.length == 0)&#123; this.head = newNode; this.tail = newNode; &#125;else&#123; this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; &#125; this.length++; &#125; //向链表的特定位置添加一个新的项 DoublyLinkedList.prototype.insert = function(position, element)&#123; let newNode = new Node(element); //越界判断 if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125;else&#123; //链表为空的情况 if (this.length == 0)&#123; this.head = newNode; this.tail = newNode; &#125;else if(position &lt; this.length/2)&#123; //插入位置为0的情况 if(position == 0)&#123; this.head.prev = newNode; newNode.next = this.head; this.head = newNode; &#125;else&#123; //插入位置为链表前半段的情况 let current = this.head; for(let i = 0; i &lt; position; i++)&#123; current = current.next; &#125; current.prev.next = newNode; newNode.prev = current.prev; current.prev = newNode; newNode.next = current; &#125; &#125;else if(position == this.length)&#123; //插入位置为尾部的情况 newNode.prev = this.tail; this.tail.next = newNode; this.tail = newNode; &#125;else&#123; //插入位置为后半段的情况 let current = this.tail; for(let i = this.length; i &gt; position; i--)&#123; current = current.prev; &#125; current.next.prev = newNode; newNode.next = current.next; current.next = newNode; newNode.prev = current; &#125; &#125; this.length++; &#125; //获取对应位置的元素 DoublyLinkedList.prototype.get = function(position) &#123; //越界判断 if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125;else&#123; let current = this.head; for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; return current.element; &#125; &#125; //返回元素在链表中的索引，如果没有则返回-1 DoublyLinkedList.prototype.indexOf = function(element)&#123; let current = this.head; let index = 0; while(current) &#123; index++; if(current.element == element)&#123; return index; &#125; current = current.next; &#125; return -1; &#125; //修改某个位置的元素 DoublyLinkedList.prototype.update = function(position, newElement)&#123; //越界判断 if(position &lt;= 0 || position &gt; this.length)&#123; return false; &#125;else&#123; let current = this.head for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; current.element = newElement; return true; &#125; &#125; //从链表中的特定位置移除一项 DoublyLinkedList.prototype.removeAt = function(position)&#123; //越界判断 if(position &lt;= 0 || position &gt; this.length)&#123; return false; &#125;else&#123; let current = this.head; if(position == 1)&#123; this.head = this.head.next; this.head.prev = null; &#125;else if(position == this.length)&#123; this.tail = this.tail.prev; this.tail.next = null; &#125;else&#123; for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; current.prev.next = current.next; current.next.prev = current.prev; &#125; &#125; this.length--; &#125; //判断链表是否为空 DoublyLinkedList.prototype.isEmpty = function()&#123; return this.length == 0; &#125; //返回链表包含的元素个数 DoublyLinkedList.prototype.size = function()&#123; return this.length; &#125; //重写toString方法 DoublyLinkedList.prototype.toString = function () &#123; let newString = &#x27;&#x27;; let current = this.head; while(current)&#123; newString += current.element + &#x27; &#x27;; current = current.next; &#125; return newString; &#125; //返回正向遍历的节点字符串形式 DoublyLinkedList.prototype.forwardString = function () &#123; return this.toString(); &#125; //返回反向遍历的节点字符串形式 DoublyLinkedList.prototype.reserveString = function()&#123; let newString = &#x27;&#x27;; let current = this.tail; while(current)&#123; newString += current.element + &#x27; &#x27;; current = current.prev; &#125; return newString; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现队列","slug":"JavaScript实现队列","date":"2021-02-13T01:22:14.000Z","updated":"2021-02-13T11:13:23.808Z","comments":true,"path":"2021/02/13/JavaScript实现队列/","link":"","permalink":"https://ez4yb.cn/2021/02/13/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"基于JavaScript的数组实现队列以及优先级队列","text":"基于JavaScript的数组实现队列以及优先级队列 队列结构​ 就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出(FIFO)形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。 图示 队列常用操作 enqueue(element)将元素加入队列 dequeue()把队列的前端元素删除,并返回被移除的元素 front()查看队列的前端元素 isEmpty()查看队列是否为空 size()查看队列元素的个数 toString()返回队列字符串 队列实现1234567891011121314151617181920212223242526272829303132333435363738function Queue()&#123; //属性 this.items = []; //方法 //将元素加入队列 Queue.prototype.enqueue = function(element)&#123; this.items.push(element); &#125; //把队列的前端元素删除，并返回被移除的元素 Queue.prototype.dequeue = function()&#123; return dequeue.shift(); &#125; //查看队列的前端元素 Queue.prototype.front = function()&#123; return this.items[0]; &#125; //查看队列是否为空 Queue.prototype.isEmpty = function()&#123; return this.items.length == 0; &#125; //查看队列的个数 Queue.prototype.size = function()&#123; return this.items.length; &#125; //返回队列的字符串 Queue.prototype.toString = function()&#123; let s = &#x27;&#x27;; for(let i = 0; i &lt; this.items.length, i++)&#123; s += this.items[i] + &#x27; &#x27;; &#125; &#125;&#125; 队列应用1击鼓传花问题：几个朋友一起玩一个游戏, 围成一圈, 开始数数, 数到某个数字的人自动淘汰，最后剩下的这个人会获得胜利, 请问最后剩下的是原来在哪一个位置上的人? 实现： 12345678910111213141516function passGame(nameList, num)&#123; //创建一个队列 let queue = new Queue(); //把名单放入队列 for(let i = 0; i &lt;nameList.length; i++)&#123; queue.enqueue(nameList[i]); &#125; //循环淘汰 while(queue.size() &gt; 1)&#123; for(let i = 0; i &lt; num - 1; i++)&#123; queue.enqueue(queue.dequeue()); &#125; queue.dequeue(); &#125; return nameList.indexOf(queue.dequeue());&#125; 优先级队列顾名思义，优先级队列即元素的排列顺序与优先级有关的队列，实现优先级队列主要又两方面需要考虑： 封装元素和优先级放在一起（可以封装一个新的构造函数） 添加元素时，将当前元素的优先级和队列中已经存在元素的优先级进行比较，以获得自己正确的位置。 优先级队列实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 //优先级队列 function PriorityQueue()&#123; function QueueElement(element, priority)&#123; this.element = element; this.priority = priority; &#125; this.items = []; PriorityQueue.prototype.dequeue = function()&#123; return this.items.shift(); &#125; //查看队列的前端元素 PriorityQueue.prototype.front = function()&#123; return this.items[0]; &#125; //查看队列是否为空 PriorityQueue.prototype.isEmpty = function()&#123; return this.items.length == 0; &#125; //查看队列元素的个数 PriorityQueue.prototype.size = function()&#123; return this.items.length; &#125; //返回队列字符串 PriorityQueue.prototype.toString = function()&#123; var s = &#x27;&#x27;; for(let i = 0; i &lt; this.items.length; i++)&#123; s += this.items[i].element + &#x27;-&#x27; + this.items[i].priority + &#x27; &#x27;; &#125; return s; &#125; //插入元素 PriorityQueue.prototype.enqueue = function (element, priority) &#123; var queueElement = new QueueElement(element, priority); if(this.items.length == 0)&#123; this.items.push(queueElement) &#125;else&#123; var added = false; for(let i = 0; i &lt; this.items.length; i++)&#123; if(queueElement.priority &lt;= this.items[i].priority)&#123; this.items.splice(i ,0 , queueElement); added = true; break; &#125; &#125; //遍历完元素，优先级都大于新插入元素，则把其放在最后 if(!added)&#123; this.items.push(queueElement); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌S"},{"title":"JavaScript实现栈","slug":"JavaScript实现栈","date":"2021-02-09T14:34:46.000Z","updated":"2021-02-11T03:35:11.433Z","comments":true,"path":"2021/02/09/JavaScript实现栈/","link":"","permalink":"https://ez4yb.cn/2021/02/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88/","excerpt":"使用JavaScriot实现栈结构（数组方式）","text":"使用JavaScriot实现栈结构（数组方式） 栈结构栈是一种“运算受限”的线性表，其特点为： LIFO（last in first out），即后入栈的元素，将会先弹出栈空间，类似把很多碟子垒在一起，后放上去的必须先拿出来 如图所示： 向一个栈插入新元素又称作进栈，入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 栈结构常见操作 push(element): 添加一个新元素到栈顶位置. pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回true，否则返回false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。这个方法和数组的length属性很类似。 栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//创建栈function Stack()&#123; //栈中的属性 this.items = []; //栈中的方法 //添加一个新元素到栈顶位置 Stack.prototype.push = function(element)&#123; //借用数组的push()方法 this.items.push(element); &#125; //移除栈顶的元素，同时返回被移除的元素 Stack.prototype.pop = function()&#123; //借用数组的pop()方法 return this.items.pop(); &#125; //返回栈顶的元素，不对栈做任何修改 Stack.prototype.peek = function()&#123; return this.items[this.items.length - 1] &#125; //如果栈里没有任何元素就返回true，否则返回false Stack.prototype.isEmpty = function()&#123; return this.items.length == 0; &#125; //移除栈里的所有元素 Stack.prototype.clear = function()&#123; this.items = []; //也可以通过多次调用pop() &#125; //返回栈里的元素个数 Stack.prototype.size = function()&#123; return this.items.length; &#125; //重写toString方法 Stack.prototype.size = function()&#123; let newString = &#x27;&#x27;; for(let i = 0; i &lt; this.items.length; i++)&#123; s += this.items[i] + &#x27; &#x27;; &#125; return newString; &#125;&#125; 栈的应用十进制转化为二进制12345678910111213141516//十进制转化为二进制（decimal to binary)function dec2bin(decNumber)&#123; let stack = new Stack(); let decNum = decNumber; while(decNum)&#123; //把decNum除以2的余数压入栈 stack.push(decNum % 2); //更新decNum为其除以2向下取整的结果 decNum = Math.floor(decNum/2); &#125; let binString = &#x27;&#x27;; while(!stack.isEmpty())&#123; binString += stack.pop(); &#125; return binString;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"Git语法总结","slug":"Git常用指令总结","date":"2021-01-29T16:00:00.000Z","updated":"2021-03-31T10:48:33.301Z","comments":true,"path":"2021/01/30/Git常用指令总结/","link":"","permalink":"https://ez4yb.cn/2021/01/30/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"​ 以一张思维导图的形式对Git常用指令做个概括","text":"​ 以一张思维导图的形式对Git常用指令做个概括","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://ez4yb.cn/tags/Git/"}],"author":"袁斌"},{"title":"Markdown语法总结","slug":"markdown常用语法总结","date":"2021-01-28T16:00:00.000Z","updated":"2021-03-31T10:52:54.638Z","comments":true,"path":"2021/01/29/markdown常用语法总结/","link":"","permalink":"https://ez4yb.cn/2021/01/29/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"​ ​ 借用WIki的简介：Markdown 是一种轻量级标记语言。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。","text":"​ ​ 借用WIki的简介：Markdown 是一种轻量级标记语言。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。 标题markdown标题可以用# + 文本的格式表示，#越多，标题级别越低。 123## 二级标题##### 五级标题 效果： 二级标题五级标题 同时由于markdown支持html语法，所以也可以用h标签来写标题 123&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h5&gt;五级标题&lt;/h5&gt; 效果 我是二级标题 我是五级标题 字体markdown本身的语法只支持粗，斜字体 1234567891011*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___ 效果： 斜体 斜体 粗体 粗体 粗斜体 粗斜体 同样的，由于支持html语法，我们也可以通过内嵌html来实现修改字体，字号，颜色 字体的设置使用face。 12&lt;font face=&quot;微软雅黑&quot; &gt;微软雅黑&lt;/font&gt;&lt;font face=&quot;华文彩云&quot; &gt;华文彩云&lt;/font&gt; 字号的设置使用size，字号数值可设为1~7，浏览器默认为3。 12&lt;font size=2 &gt;2号字&lt;/font&gt;&lt;font size=5 &gt;5号字&lt;/font&gt; 字体颜色的设置使用color 123&lt;font color=#FF000 &gt;红色&lt;/font&gt;&lt;font color=rgb(136,136,136) &gt;绿色&lt;/font&gt;&lt;font color=blue &gt;蓝色&lt;/font&gt; 效果 微软雅黑华文彩云 2号字5号字 红色绿色蓝色 分隔线可以用***或者—来生成分隔线 123***--- 效果： 特殊标识 下划线 &lt;u&gt;下划线&lt;/u&gt; 效果： 下划线 删除线 ~~删除线~~ 效果： 删除线 脚注 123我是一句话[^我是一个脚注][^我是一个脚注]: 我是脚注的内容（放在文末） 效果： 我是一句话^我是一个脚注 转义如果要显示字符本来的内容，需在前面加上反斜杠进行转义 12**文本加粗** \\*\\* 正常显示星号 \\*\\* 效果 文本加粗 ** 正常显示星号 ** 列表 无序列表 123* 无序列表- 无序列表+ 无序列表 效果： 无序列表 无序列表 无序列表 有序列表 1231. 第一列2. 第二列3. 第三列 效果： 第一列 第二列 第三列 表格注意使用—来划分表头和内容 1234|表头|表头|表头||---|---|---||内容|内容|内容||内容|内容|内容| 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 区块使用 &gt; 来来创建区块，也可以在区块中再次使用 &gt; 实现区块嵌套 123&gt;第一层&gt;&gt;第二层&gt;&gt;&gt;第三层 效果： 第一层 第二层 第三层 代码 指定语言的代码区块 123456789​```cint i = 1;print(i);​```​```javascriptlet i = 1;console.log(i);​``` 效果 12int i = 1;print(i); 12let i = 1;console.log(i); 不指定语言的代码片段 1`console.log(1)`是一个代码片段 效果: console.log(1)是一个代码片段 链接 链接使用方法如下 1这是一个链接[百度](http://baidu.com) 效果： 这是一个链接百度 也可以直接使用链接地址 1&lt;http://baidu.com&gt; 效果： http://baidu.com 还可以通过变量来设置一个链接，变量赋值在文档末尾进行 1这个链接用1来做变量[百度][1] 效果： 这个链接用1来做变量百度 图片Markdown 图片语法格式如下： 123![一只猫](markdown常用语法总结/cat.jpg)![一只猫](markdown常用语法总结/cat.jpg &quot;猫&quot;) 效果： Markdown 还没有办法指定图片的高度与宽度，但是可以使用 标签来达到目的。 1&lt;img src = &quot;cat.jpg&quot;, width = 10%&gt; 效果： 其他除了这些，还可以用markdown实现流程图，甘特图的绘制，以及利用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式的方式在编辑器插入数学公式。但是鉴于根本用不到，故不再赘述。 补充(不定期更新) 今天发现markdown无法通过tab或空格实现完美的首行缩进，故采用在首行输入两个&amp;emsp;来实现完美的中文缩进两格： 1&amp;emsp;&amp;emsp;我的名字叫吉良吉影，33岁。住在杜王町东北部的别墅区一带，未婚。我在龟友连锁店服务。每天都要加班到晚上8点才能回家。我不抽烟，酒仅止于浅尝。晚上11点睡，每天要睡足8个小时。睡前，我一定喝一杯温牛奶，然后做20分钟的放松操，上了床，马上熟睡。一觉到天亮，决不把疲劳和压力，留到第二天。医生都说我很正常 效果： &emsp;&emsp;我的名字叫吉良吉影，33岁。住在杜王町东北部的别墅区一带，未婚。我在龟友连锁店服务。每天都要加班到晚上8点才能回家。我不抽烟，酒仅止于浅尝。晚上11点睡，每天要睡足8个小时。睡前，我一定喝一杯温牛奶，然后做20分钟的放松操，上了床，马上熟睡。一觉到天亮，决不把疲劳和压力，留到第二天。医生都说我很正常","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://ez4yb.cn/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://ez4yb.cn/tags/Typora/"}],"author":"袁斌"}],"categories":[],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://ez4yb.cn/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"},{"name":"html","slug":"html","permalink":"https://ez4yb.cn/tags/html/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Git","slug":"Git","permalink":"https://ez4yb.cn/tags/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ez4yb.cn/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://ez4yb.cn/tags/Typora/"}]}