{"meta":{"title":"Blog of yb","subtitle":"学如逆水行舟","description":"Huster","author":"袁斌","url":"https://ez4yb.cn","root":"/"},"pages":[{"title":"标签","date":"2021-03-28T07:35:58.943Z","updated":"2021-03-28T07:35:58.943Z","comments":true,"path":"tags/index.html","permalink":"https://ez4yb.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JSON","slug":"JSON","date":"2021-04-28T00:50:10.000Z","updated":"2021-04-28T01:35:09.448Z","comments":true,"path":"2021/04/28/JSON/","link":"","permalink":"https://ez4yb.cn/2021/04/28/JSON/","excerpt":"JSON是一种轻量级数据格式，可以方便的表示复杂数据结构。","text":"JSON是一种轻量级数据格式，可以方便的表示复杂数据结构。 语法JSON语法支持三种类型： 简单值：字符串、数值、布尔值和null可以在JSON中出现，undefined不可以。 对象：即有序键值对，这个值可以是简单类型也可以是复杂类型。 数组：数组值可以是任意值。 JSON没有变量、函数或对象实例的概念，所有记号都只为表示结构化数据。 解析与序列化JSON对象有两个方法： stringify：将JavaScript序列化位JSON字符串。 parse：将JSON解析为原生JavaScript值。 序列化JSON.stringify允许传入三个参数: JSON.stringify(value[, replacer [, space]]) value即传入的需要序列化的对象 replacer（可选）允许传入数组或函数。 如果是函数，则序列化的值的每个属性都会经过该函数的转换和处理。 如果是数组，则只有包含在这个数组内的属性名才会被序列化到最终的JSON字符串。 如果是null或未传入，则对象所有属性都会被序列化。 space（可选）控制缩进和空格 如果是数值，表示每一级缩进的空格数 如果缩进参数是一个字符串，那么JSON字符串就会用这个字符串来缩进。 toJSON方法在要序列化的对象中添加toJSON方法，序列化时会基于这个方法返回适当的JSON表示。 示例： 1234567891011const book = &#123; title: &#x27;xxx&#x27;, time: &#x27;2021.4.27.&#x27;, content: &#x27;xxxxxxxxx&#x27;, toJSON: function()&#123; return this.title; &#125;&#125;const jsonStr = JSON.stringify(book);console.log(jsonStr); //&#x27;xxx&#x27; 解析JSON.parse允许传入两个参数 JSON.parse(text[, reviver]) text将要被解析成JavaScript值的字符串 reviver（可选）与replacer类似，可以传入函数，来修改解析生成的初始值，调用时机在parse函数返回之前。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"}],"author":"袁斌"},{"title":"柯里化函数","slug":"柯里化函数","date":"2021-04-23T00:38:48.000Z","updated":"2021-04-29T22:53:54.877Z","comments":true,"path":"2021/04/23/柯里化函数/","link":"","permalink":"https://ez4yb.cn/2021/04/23/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/","excerpt":"施工中–","text":"施工中–","categories":[],"tags":[{"name":"javascipt","slug":"javascipt","permalink":"https://ez4yb.cn/tags/javascipt/"}],"author":"袁斌"},{"title":"前后端通信","slug":"前后端通信","date":"2021-04-20T23:35:02.000Z","updated":"2021-04-28T23:58:27.296Z","comments":true,"path":"2021/04/21/前后端通信/","link":"","permalink":"https://ez4yb.cn/2021/04/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/","excerpt":"前后端通信相关学习笔记","text":"前后端通信相关学习笔记 前后端通信方式 使用浏览器访问网页 在浏览器中输入地址，按下回车。 HTML标签 浏览器在解析过程中，遇到一些特殊的标签，会再次向服务器发送请求 link/img/script/ifame 还有一些标签，浏览器解析的时候，不会向服务器发送请求，但是用户可以使用它们向服务器发送请求 a/form Ajax和Fetch 待补充 HTTPHTTP报文格式请求请求头：起始行+首部请求体 12GET请求没有请求体，数据在请求头中POST请求有请求体，数据在请求体中 响应响应头：起始行+首部响应体 HTTP方法常用的HTTP方法 GET: 获取数据 POST: 创建数据 PUT: 更新数据 DELETE: 删除数据 GET和POST对比语义GET：获取数据POST：创建数据发送数据GET通过地址在请求头中携带数据。POST既可以通过地址在请求头中携带数据，也可以通过请求体携带数据。因此：携带少量数据，可以使用GET请求，大量数据可以使用POST请求缓存GET可以被缓存POST不会被缓存安全GET和POST都不安全 HTTP状态码HTTP状态码定义服务器对请求的处理结果，是服务器返回的含义： 1XX 临时响应 100 Continue，表示服务器已经收到请求头，客户端应该继续发送请求体 101 Switching Protocols，请求者要求服务器切换协议，服务器已经确认并准备切换。 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 206 Partial Content，服务器已经成功处理的部分GET请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源 304 not modified，表示自上次请求后，请求的网页未修改过。服务器返回此相应时，不会返回网页内容 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ez4yb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"袁斌"},{"title":"apply、call和bind","slug":"apply、call和bind","date":"2021-04-15T03:56:57.000Z","updated":"2021-05-03T10:29:09.582Z","comments":true,"path":"2021/04/15/apply、call和bind/","link":"","permalink":"https://ez4yb.cn/2021/04/15/apply%E3%80%81call%E5%92%8Cbind/","excerpt":"&emsp;&emsp;apply、call和bind的主要作用都是改变this的指向，而具体的使用则有所不同。","text":"&emsp;&emsp;apply、call和bind的主要作用都是改变this的指向，而具体的使用则有所不同。 callcall()可以改变函数执行时的上下文，将一个对象的方法交给另一个对象执行，并立即执行。 call的使用规则1function.call(thisArg, arg1, arg2, ...) thisArg: function运行时所使用的this值，如果未传入，或者传入undifined或null，则指向全局对象window。(在严格模式下，则为undifined) arg1, arg2 ···: 参数列表。每个参数会映射到相应位置的function参数上。如果将所有参数作为数组传入，它们会作为一个整体映射到function的第一个参数，之后的参数都为空。 123456示例：function func(a, b, c)&#123; &#125;func.call(this, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);//接收到的参数是&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;func.call(this, [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]);//接收到的参数是[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],undefined,undefined 示例1234567891011121314function SuperType(name)&#123; this.name = name; this.sayName = function()&#123; console.log(this.name); &#125;&#125;function SubType(name)&#123; SuperType.call(this, name);&#125;const subObj = new SubType(&#x27;袁斌&#x27;);subObj.sayName();//袁斌 不传入第一个参数时： 1234567const name = &#x27;袁斌&#x27;;function sayName()&#123; console.log(this.name);&#125;sayName.call();//袁斌 call的模拟实现根据之前对call()的描述，可以把其功能拆分成如下一个步骤： 将函数设置为传入对象的属性(如果为null或undefined，则设置为window) 接受传入的参数，执行该函数 删除该函数 根据此思路，实现call(): 123456789101112Function.prototype.myCall = function(context)&#123; //判断传入对象是否为空 context = context || window; //将函数设置为传入对象的属性 context.fn = this; //传入参数,执行函数 const args = [...arguments].slice(1); const result = context.fn(...args); //删除该函数 delete context.fn(); return result;&#125; applyapply功能与call相同，它们的不同点在于对参数的处理。 apply使用规则1function.apply(thisArg, [argsArray]) 第二个参数必须是数座或者类数组，它会被转化成一个类数组映射到function对应的参数。 示例12345function fn()&#123;&#125;function.apply(this, [a, b, c]);//接受到的参数为a, b, c apply的模拟实现与call的差异只有参数处理 123456789101112Function.prototype.meApply = function(context)&#123; //判断传入对象是否为空 context = context || windows; //将函数设置为传入对象的属性 context.fn = this; //传入参数，执行函数 const args = arguments[1]; const result = context.fn(...args); //删除函数 delete context.fn; return result;&#125; bindbind()创建一个新的函数，当bind()被调用时，这个函数的this指向bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 bind使用规则1function.bind(thisArg[, arg1[, arg2[, ...]]]) call和apply改变函数this指向的同时，会立即调用这个函数。而bind仅仅返回一个新函数，在这之后调用它，才会执行。 示例12345678910const a = &#123; value: 1&#125;function print()&#123; console.log(this.value);&#125;print.bind(a);//仅返回函数，不输出任何值print.bind(a)();//输出1 因为bind返回的函数暂不执行，因此不光可以在定义它时传入参数，执行时也可以传入参数： 12345678910111213const a =&#123; value: 1&#125;function print(name, age)&#123; console.log(this.value); console.log(name); console.log(age);&#125;const fn = print.bind(a, &#x27;袁斌&#x27;);fn(21);//1 袁斌 21 同时，bind返回的函数也可以作为构造函数，将其作为构造函数调用时，传入的this会被忽略，而传入参数作为构造函数的参数: 12345678910111213141516const a =&#123; value: 1&#125;function print(name, age)&#123; this.num = 3; console.log(this.value); console.log(name); console.log(age);&#125;const Fn = print.bind(a, &#x27;袁斌&#x27;);const fn = new Fn(21);//undefined 袁斌 21console.log(fn.num);//3 bind模拟实现12345678910111213141516Function.prototype.myBind = function(context)&#123; const self = this; const args = [...arguments].slice(1); function fn()&#123;&#125; function fnBind()&#123; const bindArgs = [...arguments]; return self.apply(this instanceof fn ? this : context, args.concat(bindArgs)); &#125; fn.prototype = this.prototype; fnBind.prototype = new fn(); return fnBind;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"}],"author":"袁斌"},{"title":"排序算法","slug":"排序算法","date":"2021-04-01T07:08:55.000Z","updated":"2021-04-20T13:06:34.196Z","comments":true,"path":"2021/04/01/排序算法/","link":"","permalink":"https://ez4yb.cn/2021/04/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"简单归纳一下排序算法(施工中)","text":"简单归纳一下排序算法(施工中) 排序冒泡排序依次比较相邻元素，把较大的放到右边。以此类推执行n - 1次 12345678910111213var sortArray = function(nums) &#123; const n = nums.length; for(let i = 0; i &lt; n - 1; i++)&#123; for(let j = 0; j &lt; n - 1 - i; j++)&#123; if(nums[j] &gt; nums[j + 1])&#123; const temp = nums[j + 1]; nums[j + 1] = nums[j]; nums[j] = temp; &#125; &#125; &#125; return nums;&#125;; 选择排序找到数组最小的值，把它放在第一位，再找到第二小的值放到第二位··· 1234567891011121314151617var sortArray = function(nums) &#123; const n = nums.length; for(let i = 0; i &lt; n - 1; i++)&#123; let indexMin = i; for(let j = i; j &lt; n; j++)&#123; if(nums[j] &lt; nums[indexMin])&#123; indexMin = j; &#125; &#125; if(indexMin !== i)&#123; const temp = nums[i]; nums[i] = nums[indexMin]; nums[indexMin] = temp; &#125; &#125; return nums;&#125;; 插入排序从第二个数往前比，如果比它大就往后排，以此类推进行到最后一个数 12345678910111213var sortArray = function(nums) &#123; const n = nums.length; for(let i = 1; i &lt; n; i++)&#123; for(let j = i; j &gt; 0; j--)&#123; if(nums[j] &lt; nums[j - 1])&#123; const temp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = temp; &#125; &#125; &#125; return nums;&#125;; 归并排序先分：把数组分成两半，再递归地对把子数字分成两半，直到分成一个个单独的数。再合：把两个数合并成一个有序数组，再把有序数组进行合并，直到全部子数组合并成为一个完整的数组。 123456789101112131415161718192021var sortArray = function(nums) &#123; if(nums.length == 1) return nums; const mid = Math.floor(nums.length/2); const left = nums.slice(0, mid); const right = nums.slice(mid, nums.length); const orderLeft = sortArray(left); const orderRight = sortArray(right); const res = [] while(orderLeft.length || orderRight.length)&#123; if(orderLeft.length &amp;&amp; orderRight.length)&#123; res.push(orderLeft[0] &lt; orderRight[0] ? orderLeft.shift() : orderRight.shift()); &#125;else if(orderLeft.length)&#123; res.push(orderLeft.shift()); &#125;else&#123; res.push(orderRight.shift()) &#125; &#125; return res;&#125;; 快速排序分区：选定一个数作为基准，把比它小的放它左边，大的放右边。递归：递归地对基准前后的子数组进行分区。 123456789101112131415var sortArray = function(nums) &#123; if(nums.length &lt;= 1) return nums; const left = [], right = []; const index = Math.floor(Math.random() * nums.length); const mid = nums.splice(index, 1)[0]; for(let i = 0; i &lt; nums.length; i++)&#123; if(nums[i] &lt; mid)&#123; left.push(nums[i]); &#125;else&#123; right.push(nums[i]); &#125; &#125; return [...sortArray(left), mid, ...sortArray(right)]&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://ez4yb.cn/tags/%E7%AE%97%E6%B3%95/"}],"author":"袁斌"},{"title":"JavaScript原型与继承总结","slug":"JavaScript原型和继承","date":"2021-03-31T02:51:18.000Z","updated":"2021-04-29T22:55:09.731Z","comments":true,"path":"2021/03/31/JavaScript原型和继承/","link":"","permalink":"https://ez4yb.cn/2021/03/31/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/","excerpt":"&emsp;&emsp;每个JavaScript对象在创建的时候，就会有与之关联的另一个对象，这个对象就叫做原型，每个对象都会从“原型”继承属性。","text":"&emsp;&emsp;每个JavaScript对象在创建的时候，就会有与之关联的另一个对象，这个对象就叫做原型，每个对象都会从“原型”继承属性。 原型与原型链&emsp;&emsp;初看文字描述的时候我觉得原型链很怪异，不好理解，在结合了代码和图示后，一切都豁然开朗。那么就先来一段可以反应原型特性的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class People&#123; //人类有一个属性名字 constructor(name)&#123; this.name = name; &#125; //人类有一个方法叫吃 eat()&#123; console.log(`$&#123;this.name&#125; eat something`); &#125;&#125;//学生是人类，继承人类的属性“名字”以及方法“吃”class Student extends People&#123; //学生有两个属性，姓名和学号 constructor(name, number)&#123; super(name); this.number = number; &#125; //学生有一个方法叫自我介绍 selfIntro()&#123; console.log(`姓名$&#123;this.name&#125; 学号$&#123;this.number&#125;`); &#125;&#125;//老师是人类，继承人类的属性“名字”以及方法“吃”class Teacher extends People&#123; //老师有两个属性，名字和科目 constructor(name, major)&#123; super(name); this.major = major; &#125; //老师有一个方法叫讲授 teach()&#123; console.log(`$&#123;this.name&#125;教$&#123;this.major&#125;`); &#125;&#125;//Student的实例const me = new Student(&#x27;袁斌&#x27;,&#x27;3&#x27;);console.log(me.name);//袁斌console.log(me.number);//3me.selfIntro();//姓名袁斌 学号3me.eat();//袁斌 eat something//teacher的实例const missMa = new Teacher(&#x27;马老师&#x27;, &#x27;DSP&#x27;) console.log(missMa.name);//马老师console.log(missMa.major);//DSPmissMa.teach();//马老师教DSPmissMa.eat();//马老师 eat something &emsp;&emsp;如上可见，me是Student的实例对象，同时获得了Student的方法以及Student的父类People的方法，那么这些方法是如何获取的呢。在以上代码的基础上，我们在浏览器输入me查看： &emsp;&emsp;可以看出，me是一个Student对象，它有属性name、number，以及一个__proto__属性，该___proto__属性中有一个selfIntro方法，一个__proto__属性，**以及一个constructor属性指向Class Student**，即Student构造函数。我们把这个__proto__属性写作me.__proto__。再输入Student.prototype查看： &emsp;&emsp;可以很清晰的看到，它和上面的me.__proto__内容相同。同时，它的__proto__有一个constructor属性指向 Class People，结合上面的黑字部分，我们可以判断出，Student.prototype是people的一个实例。我们可以进一步验证以上推断： &emsp;&emsp;由此我们可以根据这些关系画出一个一目了然的图示（为了简化省略了Teacher）： &emsp;&emsp;这便是JavaScript的原型链，当我们调用一个对象的方法时，依次查找本对象的属性，如果没有，就沿着__proto__属性向上查找，直到找到同名方法。 继承类继承&emsp;&emsp;最简洁的继承方式莫过于前文使用过的，通过Class和extends实现继承，子类extends父类，用super调用父类构造函数即可实现继承。需要注意的是： 函数声明可以提升，而类定义不能； 函数受函数作用域限制，而类受块作用域限制 创建一个对象实例时，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象。调回类构造函数时如果忘了使用new则会抛出错误。 Class是ES6新增的语法，而在这之前，JavaScript主要通过原型和构造函数实现继承，事实上，类继承背后使用的仍然是原型和构造函数的概念。 原型链继承12345678910111213141516171819//原型链继承function SuperType()&#123; this.name = &#x27;袁斌&#x27; this.arr = [1, 2];&#125;SuperType.prototype.getName = function()&#123; console.log(this.name);&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType();let sub1 = new SubType();sub1.getName();//袁斌 &emsp;&emsp;它存在两个问题： 原型中包含的引用会在所有实例间共享，如下所示 123456789console.log(sub1.arr);//[1, 2]let sub2 = new SubType();sub2.name = &#x27;某某&#x27;;sub2.arr.push(3); sub1.getName();//袁斌sub2.getName();//某某console.log(sub2.arr);//[1, 2, 3]console.log(sub2.__proto__.name);//袁斌 注意：name属性看似没有共享是因为sub2.name = &#39;某某&#39;是为sub2添加了name值，并不是修改了原型链上的name。代码最后一行可见原型上的name值并没有改变。 子类型在实例化时不能给父类型的构造函数传参。 因此，原型链继承基本不会被单独使用。 盗用构造函数12345678910111213141516//盗用构造函数function SuperType()&#123; this.arr = [1, 2];&#125;function SubType()&#123; SuperType.call(this);&#125;let sub1 = new SubType();let sub2 = new SubType();sub2.arr.push(3);console.log(sub1.arr);//[1, 2]console.log(sub2.arr);//[1, 2, 3] 本质是在新的SubType对象中运行了SuperType()中的所有初始化方法，因而每个实例都会有自己的arr属性。 同时也允许在子类构造函数中向父类构造函数传参： 12345678910111213function SuperType(name)&#123; this.name = name;&#125;function SubType(name)&#123; SuperType.call(this, name); this.age = 21;&#125;let sub1 = new SubType(&#x27;袁斌&#x27;);console.log(sub1.name);//袁斌console.log(sub1.age);//21 &emsp;&emsp;但是它也存在一个问题：函数不能重用，每次创建实习都会创建一遍方法。 因此，盗用构造函数基本也不能单独使用。 组合继承12345678910111213141516171819202122232425262728293031323334//组合继承function SuperType(name)&#123; this.name = name; this.arr = [1, 2];&#125;SuperType.prototype.getName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.getAge = function()&#123; console.log(this.age);&#125;let sub1 = new SubType(&#x27;袁斌&#x27;, 21);let sub2 = new SubType(&#x27;某某&#x27;, 1);sub1.arr.push(3);console.log(sub1.arr);//[1, 2, 3]console.log(sub2.arr);//[1, 2]sub1.getName();//袁斌sub2.getName();//某某sub1.getAge();//21sub2.getAge();//1 &emsp;&emsp;可以看出，组合继承使用原型链继承原型上的属性和方法，而通过盗用构造函数来继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。 原型式继承1234567891011121314151617//原型式继承function object(o)&#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;let a = &#123; name: &#x27;袁斌&#x27;, arr: [1, 2]&#125;let b = object(a);console.log(b.__proto__);//&#123; name: &#x27;袁斌&#x27;, arr: [ 1, 2 ] &#125;b.arr.push(3);console.log(a.arr);//[1, 2, 3] &emsp;&emsp;等同于ES5中的Object.create()方法，本质上是对传入的对象执行了一次浅复制，与原型链继承存在同样的问题。它适合“不需要单独创建构造函数，但仍然需要在对象间共享信息”的场合。 寄生式继承12345678//寄生式继承function createObj(o)&#123; let clone = object(o);//即上面的原型式继承方法，也可用Object.create()代替 clone.sayHi = function()&#123; console.log(&#x27;Hi&#x27;); &#125;; return clone;&#125; &emsp;&emsp;盗用构造函数类似，它也会导致函数难以重用。 寄生组合式继承123456789101112131415161718192021222324252627282930313233343536373839//寄生组合式继承function inheritPrototype(subType, superType)&#123; let prototype = Object.create(superType.prototype);//创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype;//赋值对象&#125;function SuperType(name)&#123; this.name = name; this.arr = [1, 2];&#125;SuperType.prototype.getName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.getAge = function()&#123; console.log(this.age);&#125;let sub1 = new SubType(&#x27;袁斌&#x27;, 21);let sub2 = new SubType(&#x27;某某&#x27;, 1);sub1.arr.push(3); console.log(sub1.arr);//[1, 2, 3]console.log(sub2.arr);//[1, 2]sub1.getName();//袁斌sub2.getName();//某某sub1.getAge();//21sub2.getAge();//1 &emsp;&emsp;可见寄生组合式继承仅仅是把组合式继承中的SubType.prototype = new SuperType()改为以下过程：先创建一个父类原型的副本，然后给返回的prototype设置construtor属性，解决组合式继承由于重写原型导致constructor丢失的问题，然后将新创建的对象赋给子类型的原型。这样相比组合式继承，少调用了一个父类构造函数，避免了SubType.prototype中不必要的属性。而且，原型链仍保持不变，还能正常使用instanceOf和isPrototypeOf()。综上所述，“寄生组合式继承是引用类型继承的最佳模式“。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"}],"author":"袁斌"},{"title":"CSS的Flex布局","slug":"CSS的Flex布局","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-23T00:25:48.765Z","comments":true,"path":"2021/03/24/CSS的Flex布局/","link":"","permalink":"https://ez4yb.cn/2021/03/24/CSS%E7%9A%84Flex%E5%B8%83%E5%B1%80/","excerpt":"Flex属性多且杂，在此做个总结以加深印象。","text":"Flex属性多且杂，在此做个总结以加深印象。 Flex设置可以对任一容器设置flex属性。块级元素 1display: flex; 行内元素 1display: inline-flex; 对容器设置flex属性后，其子元素的float,clear,vertical-align将失效。 容器属性flex-direction定义主轴的方向。 row（默认）: 主轴为水平方向，起点在左端 row-reverse: 主轴为水平方向，起点在右端 column: 主轴为垂直方向，起点在顶部 colomn-reverse: 主轴为垂直方向，起点在底部 flex-wrap定义子元素换行方式。 nowrap（默认）: 不换行 wrap: 换行，第一行在上方 wrap-reverse: 换行，第一行在下方 flex-flow它是flex-direction和flex-wrap的简写形式 ，其值的形式为flex-direction flex-wrap默认为row || nowrap。 justify-content定义子元素在主轴的排列方式。 flex-start（默认值）: 左对齐 flex-end: 右对齐 center: 居中 space-between: 两端对齐，子元素间隔相等 space-around: 每个子元素两侧间隔相等，为子元素与边框距离的两倍 align-items定义子元素在交叉轴的对齐方式。 flex-start: 对齐交叉轴的起点 flex-end: 对齐交叉轴的终点 center: 对齐交叉轴的中点 baseline: 对齐子元素第一行文字的基线 stretch(默认): 如果子元素未设置高度，或设置为auto，将占满整个容器高度 align-contents定义了多根轴线的对齐方式，如果子元素只有一根轴线，改属性不起作用。 flex-start: 对齐交叉轴的起点 flex-end: 对齐交叉轴的终点 center: 对齐交叉轴的中点 space-between: 与交叉轴两端对齐，轴线之间间隔相等 space-around: 每根轴线间隔相等，为轴线与边框距离的两倍 stretch(默认): 占满整个交叉轴 子元素属性order定义子元素的排列顺序，数值越小排列越靠前。 flex-grow定义子元素放大比例，默认为0，即不放大。 flex-shrink定义子元素缩小比例， 默认为1， 即不缩小。 flex-basis定义在分配多余空间之前，子元素占据的空间，默认为auto，即子元素本来的大小。 flex它是前三个属性的简写形式，其值形式为flex-grow flex-shrink flex-basis。默认为0 1 auto，它有两个快捷值： auto = 1 1 auto none = o o auto align-self它可以覆盖align-items属性，默认为auto，表示继承父元素的align-items属性。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"树的常见算法","slug":"树的常见算法","date":"2021-03-18T23:33:00.000Z","updated":"2021-04-17T14:02:53.427Z","comments":true,"path":"2021/03/19/树的常见算法/","link":"","permalink":"https://ez4yb.cn/2021/03/19/%E6%A0%91%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/","excerpt":"持续更新","text":"持续更新 树的深度优先遍历12345//递归function dfs(root)&#123; console.log(root.val); root.children.forEach(dfs);&#125;; 树的广度优先遍历123456789101112//队列function bfs(root)&#123; const q = []; q.push(root) while(q.length &gt; 0)&#123; const n = q.shift(); console.log(n.val); n.children.forEach(child =&gt; &#123; q.push(child); &#125;) &#125;&#125; 二叉树的先序遍历12345678910111213//递归var preorderTraversal = function(root) &#123; const res = []; const presorder = (root) =&gt; &#123; if(!root) return; res.push(root.val); presorder(root.left, res); presorder(root.right, res); &#125; presorder(root); return res;&#125;; 1234567891011121314//非递归var preorderTraversal = function(root) &#123; const res = [], stack = [root]; if(!root) return res; while(stack.length)&#123; const n = stack.pop(); res.push(n.val); if(n.right) stack.push(n.right); if(n.left) stack.push(n.left); &#125; return res;&#125;; 二叉树的中序遍历1234567891011121314//递归var inorderTraversal = function(root) &#123; const res = []; const inorder = (root) =&gt; &#123; if(!root) return; inorder(root.left); res.push(root.val); inorder(root.right); &#125; inorder(root); return res;&#125;; 1234567891011121314151617///非递归var inorderTraversal = function(root) &#123; const res = [], stack = []; let p = root; while(p || stack.length)&#123; while(p)&#123; stack.push(p); p = p.left; &#125; const n = stack.pop(); res.push(n.val); p = n.right; &#125; return res;&#125;; 二叉树的后序遍历12345678910111213var postorderTraversal = function(root) &#123; const res = []; const postorder = root =&gt; &#123; if(!root) return; postorder(root.left); postorder(root.right); res.push(root.val); &#125; postorder(root); return res;&#125;; 1234567891011121314//非递归var postorderTraversal = function(root) &#123; const res = [], stack = [root]; if(!root) return res; while(stack.length)&#123; const n = stack.pop(); res.push(n.val); if(n.left) stack.push(n.left); if(n.right) stack.push(n.right); &#125; return res.reverse();&#125;; 二叉树的最大深度12345678910111213141516var maxDepth = function(root) &#123; let res = 0; const dfs = (n, depth) =&gt; &#123; if(!n) return; if(!n.left &amp;&amp; !n.right)&#123; res = Math.max(res, depth); &#125; dfs(n.left, depth + 1); dfs(n.right, depth + 1); &#125; dfs(root, 1); return res;&#125;; 二叉树的最小深度1234567891011121314var minDepth = function(root) &#123; if(!root)&#123; return 0; &#125; //用队列储存每一层节点 const q = [[root, 1]]; //广度优先遍历 while(q.length)&#123; const [n, depth] = q.shift(); if(n.left == null &amp;&amp; n.right == null) return depth; if(n.left) q.push([n.left, depth + 1]); if(n.right) q.push([n.right, depth + 1]); &#125;&#125;; 二叉树的层序遍历123456789101112131415161718var levelOrder = function(root) &#123; if(!root) return []; const res = [] const q = [root] while(q.length)&#123; let len = q.length; res.push([]); while(len--)&#123; const n = q.shift(); res[res.length - 1].push(n.val); if(n.left) q.push(n.left); if(n.right) q.push(n.right); &#125; &#125; return res;&#125;; 二叉树路径总和1234567891011121314var hasPathSum = function(root, targetSum) &#123; if(!root) return false; let res = false; const dfs = (n, sum) =&gt; &#123; if(sum === targetSum &amp;&amp; !n.left &amp;&amp; !n.right)&#123; res = true; &#125; if(n.left) dfs(n.left, n.left.val + sum); if(n.right) dfs(n.right, n.right.val + sum); &#125; dfs(root, root.val); return res;&#125;;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"重排和重绘","slug":"重排和重绘","date":"2021-03-18T19:24:47.000Z","updated":"2021-03-18T19:30:09.331Z","comments":true,"path":"2021/03/19/重排和重绘/","link":"","permalink":"https://ez4yb.cn/2021/03/19/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"施工中—","text":"施工中—","categories":[],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://ez4yb.cn/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"}],"author":"袁斌"},{"title":"JavaScript深拷贝","slug":"JavaScript深拷贝","date":"2021-03-15T09:14:06.000Z","updated":"2021-04-20T23:32:17.639Z","comments":true,"path":"2021/03/15/JavaScript深拷贝/","link":"","permalink":"https://ez4yb.cn/2021/03/15/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"JavaScript存在值类型和引用类型的区分，当我们想根据一个已存在的引用类型复制出一个新的引用类型时，我们就需要通过深拷贝来实现。","text":"JavaScript存在值类型和引用类型的区分，当我们想根据一个已存在的引用类型复制出一个新的引用类型时，我们就需要通过深拷贝来实现。 类型区分对一个值类型进行复制后，复制值与之前的值没有关系，二者可以单独修改 1234let a = 2;let b = a;b = 4;console.log(b) //4 对一个引用类型进行复制，实际上是使新对象的指针指向原对象指针所指向的位置。所以对新对象的属性进行修改时，会通过指针去修改新旧对象共同指向的内容。 12345678910111213141516const a = &#123; age: 20, name: &#x27;xxx&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Wuhan&#x27; &#125;&#125;const b = a;b.age = 21;b.address.city = &#x27;Jiangxi&#x27;console.log(a.age); // 21console.log(a.address.city); //Jiangxi 由此可见，通过这种方式复制一个引用类型，并没有创建一个新对象，当我们并不想修改原先的引用类型值的时候，就需要进行“深拷贝”，如图所示： 深拷贝方法一 ：递归遍历12345678910111213141516171819202122232425262728293031323334353637383940414243function deepClone(obj)&#123; if(obj == null || typeof obj !== &#x27;object&#x27;)&#123; return obj; &#125; let result; //初始化返回结果 if(obj instanceof Array)&#123; result = []; &#125;else&#123; result = &#123;&#125;; &#125; for(const key in obj)&#123; //保证key不是原型的值 if (obj.hasOwnProperty(key))&#123; //递归调用 result[key] = deepClone(obj[key]); &#125; &#125; return result;&#125;const a = &#123; age: 20, name: &#x27;xxx&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Wuhan&#x27; &#125;&#125;const b = deepClone(a);b.age = 21;b.name = &#x27;yyy&#x27;;b.address.city = &#x27;Xiangyang&#x27;;console.log(a); //&#123; age: 20, name: &#x27;xxx&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Wuhan&#x27; &#125; &#125;console.log(b); //&#123; age: 21, name: &#x27;yyy&#x27;, address: &#123; province: &#x27;Hubei&#x27;, city: &#x27;Xiangyang&#x27; &#125;&#125; 可见执行深拷贝后成功达到了目的。 方法二：JSON.parse(JSON.stringify(obj))利用JSON.stringify 将对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)对象。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"}],"author":"袁斌"},{"title":"圣杯布局和双飞翼布局","slug":"圣杯布局和双飞翼布局","date":"2021-03-11T08:11:18.000Z","updated":"2021-04-16T23:34:09.712Z","comments":true,"path":"2021/03/11/圣杯布局和双飞翼布局/","link":"","permalink":"https://ez4yb.cn/2021/03/11/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"pc网页三栏式布局","text":"pc网页三栏式布局 布局特点 三栏布局，中间一栏最先渲染和加载 两侧内容固定，中间内容随宽度自适应 实现方法 使用float布局 两侧使用margin负值，以便和中间内容重叠 防止中间内容被两侧覆盖，圣杯布局用padding，双飞翼布局用margin 圣杯布局1234567&lt;div id = &quot;header&quot;&gt;header&lt;/div&gt;&lt;div id = &quot;container&quot; class = &quot;clearfix&quot;&gt; &lt;div id = &quot;center&quot; class = &quot;column&quot;&gt;center&lt;/div&gt; &lt;div id = &quot;left&quot; class = &quot;column&quot;&gt;left&lt;/div&gt; &lt;div id = &quot;right&quot; class = &quot;column&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div id = &quot;footer&quot;&gt;footer&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#container .column&#123; float: left; &#125; #header &#123; text-align: center; background-color: #f1f1f1; &#125; /* 根据left和right的宽度设置padding，给出显示两边内容的空间 */ #container&#123; padding-left: 200px; padding-right: 150px; &#125; #center &#123; background-color: #ccc; width: 100% ; &#125; #left &#123; background-color: yellow; width: 200px; /* 通过margin-left负值使left和center横向重合 */ margin-left: -100%; /* 通过relative定位，设置right把自身向左推200px */ position: relative; right: 200px; &#125; #right &#123; background-color: red; width: 150px; /* 设置margin-right负值，使自身宽度在外界看来为0，不再需要换行，自动移至center右侧 */ margin-right: -150px; &#125; #footer &#123; text-align: center; background-color: #f1f1f1; &#125; /* 通过clearfix使footer被撑到container下方 */ .clearfix::after&#123; display: block; clear: both; content: &#x27;&#x27;; &#125; 效果： 双飞翼布局1234567891011&lt;div id=&quot;main&quot; class=&quot;col&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt; this is main &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;left&quot; class=&quot;col&quot;&gt; this is left&lt;/div&gt;&lt;div id=&quot;right&quot; class=&quot;col&quot;&gt; this is right&lt;/div&gt; 12345678910111213141516171819202122232425.col &#123; float: left; &#125; #main &#123; width: 100%; height: 200px; background-color: #ccc; &#125; #main-wrap &#123; margin: 0 190px 0 190px; &#125; #left &#123; width: 190px; height: 200px; background-color: #0000FF; margin-left: -100%; &#125; #right &#123; width: 190px; height: 200px; background-color: #FF0000; margin-left: -190px; &#125; 效果：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"行内元素、块级元素","slug":"行内元素、块级元素","date":"2021-03-06T16:35:44.000Z","updated":"2021-03-18T17:43:01.220Z","comments":true,"path":"2021/03/07/行内元素、块级元素/","link":"","permalink":"https://ez4yb.cn/2021/03/07/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/","excerpt":"简单总结行内元素、块级元素、行内块元素的异同","text":"简单总结行内元素、块级元素、行内块元素的异同 块级元素： 独占一行 设置width和height有效。（默认width是父元素的100%，height取决于内容的height） 设置margin，上下左右有效 设置padding，上下左右有效 常见块级元素：div、h1~6、p、ul 行内元素： 不会独占一行 设置width和height无效。（默认width取决于内容的width，默认height取决于内容的height） 设置margin，左右有效，上下无效 设置padding，上下左右都有效，但不建议设置上下，易导致对上下元素的覆盖。 常见行内元素：a 、span、 em、 i、 b、 strong 行内块元素 不会独占一行 设置width和height有效 设置margin，上下左右有效 设置padding，上下左右有效 使用display属性可以将三者互相转换： display: inline转换为行内元素 display: block转换为块级元素 display: inline-block转换为行内块级元素 display: none元素不显示","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://ez4yb.cn/tags/html/"}],"author":"袁斌"},{"title":"CSS浮动","slug":"CSS浮动","date":"2021-03-05T14:04:29.000Z","updated":"2021-04-19T11:23:13.736Z","comments":true,"path":"2021/03/05/CSS浮动/","link":"","permalink":"https://ez4yb.cn/2021/03/05/CSS%E6%B5%AE%E5%8A%A8/","excerpt":"浮动布局可以使元素脱离正常流，块级元素会忽略浮动元素，而行内元素会环绕浮动元素。","text":"浮动布局可以使元素脱离正常流，块级元素会忽略浮动元素，而行内元素会环绕浮动元素。 Float示例： 123456&lt;div class = &#x27;border&#x27;&gt; &lt;div class = &#x27;float_lightcoral&#x27;&gt;&lt;/div&gt; &lt;div class = &#x27;normal_red&#x27;&gt;&lt;/div&gt; &lt;div class = &#x27;float_blue&#x27;&gt;&lt;/div&gt; 我的名字叫吉良吉影，33岁。住在杜王町东北部的别墅区一带，未婚。我在龟友连锁店服务。每天都要加班到晚上8点才能回家。我不抽烟，酒仅止于浅尝。晚上11点睡，每天要睡足8个小时。睡前，我一定喝一杯温牛奶，然后做20分钟的放松体操，上了床，马上熟睡。一觉到天亮，决不把疲劳和压力，留到第二天。医生都说我很正常. &lt;/div&gt; 12345678910111213141516171819202122232425.border&#123; border:1px black solid; width: 500px; height: 200px; &#125; .float_lightcoral&#123; float: left; width: 100px; height: 50px; background-color: lightcoral; &#125; .float_blue&#123; float: left; width: 100px; height: 50px; background-color: blue; &#125; .normal_red&#123; width: 160px; height: 50px; background-color: red; &#125; 效果： 由图可见，红色块级元素忽略了浮动元素，排在左上角，但是一部分被粉色浮动元素遮挡。而行内元素，即文字部分，受到蓝色浮动元素的影响，环绕其展开。 float可设置的值 left：元素向左浮动 right：元素向右浮动 none：默认值，不浮动 inherit：从父元素继承浮动值 清除浮动因为浮动元素不能撑开包含块，有时需要清楚浮动以使元素正常显示。其方法主要有两种： BFC如前所述 clearfix其原理是给元素尾部设置一个内容为空的伪类，并清除浮动，以撑开包含块。下面是个简单的例子： 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; 123456789101112131415161718192021222324.container &#123; width: 500px; background-color: black;&#125;.left &#123; width: 200px; height: 300px; background-color: red; float: left;&#125;.right &#123; width: 200px; height: 200px; background-color: green; float: right;&#125;.footer &#123; width: 400px; height: 50px; background-color: blue;&#125; 效果如图： 由图可见，为了使布局正常显示，footer应该被撑开，排列在最下面。 遂给container添加clearfix： 12345&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; 12345.container.clearfix::after&#123; clear: both; content: &#x27;&#x27;; display: block;&#125; 效果：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"CSS的position定位","slug":"CSS的position定位","date":"2021-03-02T17:41:32.000Z","updated":"2021-04-19T11:21:26.110Z","comments":true,"path":"2021/03/03/CSS的position定位/","link":"","permalink":"https://ez4yb.cn/2021/03/03/CSS%E7%9A%84position%E5%AE%9A%E4%BD%8D/","excerpt":"CSS的定位方式由position元素的设置决定","text":"CSS的定位方式由position元素的设置决定 position属性可以设定的值有： static relative absolute fixed sticky staticstatic是position属性的默认值，浏览器会按照源码的顺序，决定每个元素的位置，这称为“正常流”(Normal flow)。 relative表示元素相对于默认位置(即static)偏移，可以由left、right、top、bottom控制偏移量 absolute表示元素相对于父元素偏移，且该父元素不能是static定位，否则定位基点就会变成整个网页的根元素html。和relative类似，absolute定位也需用left、right、top、bottom控制偏移量 absolute定位的元素会被“正常流”忽略，即在正常流中，该元素所占空间为零 fixed表示元素相对于浏览器窗口绝对定位 stickysticky定位可以使元素呈现“动态固定”的效果，当父元素开始脱离视窗时，只要与sticky元素的距离达到生效门槛，元素定位从relative自动切换为fixed；等父元素完全脱离视窗时，元素定位从fixed自动切换为relative","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"BFC总结","slug":"BFC总结","date":"2021-03-01T15:12:44.000Z","updated":"2021-03-31T10:54:55.627Z","comments":true,"path":"2021/03/01/BFC总结/","link":"","permalink":"https://ez4yb.cn/2021/03/01/BFC%E6%80%BB%E7%BB%93/","excerpt":"BFC的理解与应用","text":"BFC的理解与应用 BFC简介BFC（Block format context， 块级格式化上下文)，它是页面中一块独立的渲染区域，内部元素的渲染不会影响边界外部的元素。 触发BFC只要元素满足下列任一条件即可触发BFC： body根元素 float是none以外的值 position是absolute或fixed overflow是visible以外的值(hidden, auto, scroll) display是inline-block, flex或table-cells BFC应用1.通过把相邻元素放在不同BFC中，可以清除外边距折叠 2.清楚浮动","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"CSS盒模型总结","slug":"CSS盒模型总结","date":"2021-02-27T13:44:49.000Z","updated":"2021-03-11T07:51:00.657Z","comments":true,"path":"2021/02/27/CSS盒模型总结/","link":"","permalink":"https://ez4yb.cn/2021/02/27/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"对盒子模型做个简单概括","text":"对盒子模型做个简单概括 盒模型类别 标准盒模型 由四个部分组成： content box: 用来显示内容的区域，通过”width”和”height”设置大小 padding box: 内边距 border box: 边框 margin box: 外边距 替代(IE)盒模型 如图可以很直观的看出，替代盒模型相比IE盒模型的区别在于它的width和height等于content + padding + border的宽度。 可以通过设置box-sizing来设置盒子的类型（默认为标准盒模型）: box-sizing: content-box：标准盒模型 box-sizing: border-box： IE盒模型 padding可以整体设置大小，也可以分别各个方向分别设置，如： padding-top: 30px; padding-right: 20px; padding-bottom: 40px; padding-left: 100px; padding:30px 20px 40px 100px; 如果写了四个值，则顺序为：上 右 下 左； 如果写了三个值，则顺序为：上 右 下。自动设置左 = 右。 如果只写了两个值，如padding: 30px 40px，则等价于padding: 30px 40px 30px 40px; margin属性设置和padding类似 borderborder的属性设置顺序为：粗细 类型 颜色：如 border: 1px ridge red 通过border画三角形 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type = &quot;text/css&quot;&gt; div&#123; width: 0px; height: 0px; border: 50px solid; border-color: red white white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： margin纵向重叠 相邻元素的margin-top和margin-bottom会发生重叠 空白内容也会重叠 如： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type = &quot;text/css&quot;&gt; p &#123; font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;P&gt;AAA&lt;/P&gt; &lt;P&gt;&lt;/P&gt; &lt;P&gt;&lt;/P&gt; &lt;P&gt;CCC&lt;/P&gt;&lt;/body&gt;&lt;/html&gt; 效果： margin负值 margin-top和margin-left负值，元素向上，向左移动 margin-right负值，右侧元素左移，自身不受影响 margin-bottom负值，下方元素上移，自身不受影响","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"}],"author":"袁斌"},{"title":"JavaScript实现二叉搜索树","slug":"JavaScript实现二叉搜索树","date":"2021-02-22T11:01:50.000Z","updated":"2021-03-18T18:36:08.541Z","comments":true,"path":"2021/02/22/JavaScript实现二叉搜索树/","link":"","permalink":"https://ez4yb.cn/2021/02/22/JavaScript%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"使用JavaScript实现二叉搜索树(施工中)","text":"使用JavaScript实现二叉搜索树(施工中) 二叉搜索树一个非空的二叉搜索树（BST，Binary Search Tree）满足以下性质： 非空左子树的所有键值均小于其根节点的键值 非空右子树的所有键值均大于其根节点的键值 左，右子树本身也是二叉搜索树 因此，树中相对较小的值总保存在左节点上，相对较大的值总保存在右节点上。这样一来，在二叉搜索树中查找一个值，其实是模仿了二分查找法，可以很大程度地提升效率。 二叉搜索树的操作 insert(key)：向树中插入一个新的键。 search(key)：在书中查找一个键，存在返回true，不存在则返回false。 inOrderTraversal()： 中序遍历所有节点 preOrderTraversal()： 先序遍历所有节点 postOrderTraversal()： 后序遍历所有节点 min()： 返回树中最小的键值 max()： 返回树中最大的键值 remove(key)： 从树中移除某个键 二叉搜索树的实现1","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现哈希表","slug":"JavaScript实现哈希表","date":"2021-02-19T11:14:37.000Z","updated":"2021-03-30T00:06:49.163Z","comments":true,"path":"2021/02/19/JavaScript实现哈希表/","link":"","permalink":"https://ez4yb.cn/2021/02/19/JavaScript%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"使用JavaScript通过链地址法实现哈希表","text":"使用JavaScript通过链地址法实现哈希表 哈希表&emsp;&emsp;哈希表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。&emsp;&emsp;给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。 哈希表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164function HashTable()&#123; //属性 this.storage = []; this.count = 0; this.limit = 7; //方法 //哈希函数 HashTable.prototype.hasFunc = function(str, size)&#123; let hashcode = 0; for(let i = 0; i &lt; str.length; i++)&#123; hashcode = 37 * hashcode + str.charCodeAt(i) &#125; let index = hashcode % size; return index; &#125; //判断是否为质数 HashTable.prototype.isPrime = function(num)&#123; if(num &lt;= 1)&#123; return false; &#125;else&#123; for(let i = 2; i &lt;= Math.sqrt(num); i++)&#123; if(num % i == 0)&#123; return false; &#125; &#125; return true; &#125; &#125; //插入与修改 HashTable.prototype.put = function(key, value)&#123; //根据key获取index let index = this.hasFunc(key, this.limit); //根据index获取bucket let bucket = this.storage[index]; //判断bucket是否为空 if(!bucket)&#123; bucket = []; this.storage[index] = bucket; &#125; //判断是否是修改数据 for(let i = 0; i &lt; bucket.length; i++)&#123; let tuple = bucket[i]; if(tuple[0] == key)&#123; tuple[1] = value; return; &#125; &#125; //执行添加操作 bucket.push([key, value]); this.count++; //判断是否需要扩容 if(this.count &gt; 0.75 * this.limit)&#123; let newLimit = this.limit * 2; while(!this.isPrime(newLimit))&#123; newLimit++; &#125; this.resize(newLimit); &#125; &#125; //获取 HashTable.prototype.get = function(key)&#123; //根据key获取index let index = this.hasFunc(key, this.limit); //根据index获取bucket let bucket = this.storage[index]; //判断bucket是否为空 if(!bucket)&#123; return null; &#125; //查找key for(let i = 0; i &lt; bucket.length; i++)&#123; let tuple = bucket[i]; if(tuple[0] == key)&#123; return tuple[1]; &#125; &#125; return null; &#125; //删除 HashTable.prototype.remove = function(key)&#123; //根据key获取index let index = this.hasFunc(key, this.limit); //根据index获取bucket let bucket = this.storage[index]; //判断bucket是否为空 if(!bucket)&#123; return false; &#125; //查找key并删除 for(let i = 0; i &lt; bucket.length; i++)&#123; let tuple = bucket[i]; if(tuple[0] == key)&#123; bucket.splice(i, 1); this.count--; //判断是否需要缩小容量 if(this.count &gt; 7 &amp;&amp; this.count &lt; 0.25 * this.limit)&#123; let newLimit = Math.floor(this.limit/2); while(!this.isPrime(newLimit))&#123; newLimit++; &#125; this.resize(newLimit); &#125; &#125; &#125; return null; &#125; //判断是否为空 HashTable.prototype.isEmpty = function () &#123; return this.count == 0; &#125; //获取元素个数 HashTable.prototype.size = function()&#123; return this.count; &#125; //扩容 HashTable.prototype.resize = function (newLimit)&#123; //保留旧的数组内容 let oldStorage = this.storage; //重置所有属性 this.storage = []; this.count = 0; this.limit = newLimit; //遍历旧数组 for(let i = 0; i &lt; oldStorage.length; i++)&#123; let bucket = oldStorage[i]; if(bucket == null)&#123; continue; &#125;else &#123; for(let j = 0; j &lt; bucket.length; j++)&#123; let tuple = bucket[i]; this.put(tuple[0], tuple[1]); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现集合","slug":"JavaScript实现集合","date":"2021-02-17T00:29:44.000Z","updated":"2021-03-31T10:54:14.247Z","comments":true,"path":"2021/02/17/JavaScript实现集合/","link":"","permalink":"https://ez4yb.cn/2021/02/17/JavaScript%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/","excerpt":"虽然es6已经包括了Set类，可以直接使用，但为了了解集合的内部实现机制，我尝试自己来封装一下这个Set类。","text":"虽然es6已经包括了Set类，可以直接使用，但为了了解集合的内部实现机制，我尝试自己来封装一下这个Set类。 集合的特点 集合通常是由一组无序的不能重复的元素构成 可以看作一种特殊的数组，特殊在于里面的元素没有顺序也不能重复 集合常用操作 add(value): 向集合中添加一个新的项 remove(value): 从集合中移除一个值 has(value): 判断集合中是否存在该值 clear(): 移除集合中的所有项 size(): 返回集合所包含元素的数量 values(): 返回一个包含集合中所有值的数组 集合的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Set()&#123; //属性 this.items = &#123;&#125;; //方法: //向集合添加一个新的项 Set.prototype.add = function(value)&#123; //判断集合中是否已存在该元素 if(this.has(value))&#123; return false; &#125;else&#123; this.items[value] = value; return true; &#125; &#125; //从集合中移除一个值 Set.prototype.remove = function()&#123; if(this.has(value))&#123; return false; &#125;else&#123; delete this.items[value]; return true; &#125; &#125; //如果值在集合中，返回true，否则返回false Set.prototype.has = function(value)&#123; return this.items.hasOwnProperty(value); &#125; //移除集合中的所有项 Set.prototype.clear = function()&#123; this.items = &#123;&#125;; &#125; //返回集合中所包含元素的数量 Set.prototype.size = function()&#123; return Object.keys(this.items).length; &#125; //返回一个包含集合中所有值的数组 Set.prototype.values = function () &#123; return Object.keys(this.items); &#125;&#125; 集合间的操作 求两集合并集 12345678910111213141516171819Set.prototype.union(otherSet)&#123; //创建一个新的Set实例储存并集结果 let unionSet = new Set(); //取出原集合的值 let Values = this.values(); //把取出的值插入unionSet for(let i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]); &#125; //取出另一集合的值 values = otherset.values(); for(let i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]; &#125; return unionset;&#125; 求两集合交集 12345678910111213Set.prototype.intersection = function(otherSet)&#123; let intersectionSet = new Set(); let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; //如果该值也存在于另一个集合，则存入 if(otherSet.has(values[i]))&#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet;&#125; 求两集合差集 12345678910111213Set.prototype.difference = function(otherSet)&#123; let differeneSet = new Set(); let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; //如果该值不存在于另一个集合，则存入 if(otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return difference; &#125; 子集判断 1234567891011Set.prototype.subset = function(otherset)&#123; let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; if(!otherset.has(values[i]))&#123; return false; &#125; return true; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现链表","slug":"JavaScript实现链表","date":"2021-02-14T23:30:12.000Z","updated":"2021-03-31T10:54:05.449Z","comments":true,"path":"2021/02/15/JavaScript实现链表/","link":"","permalink":"https://ez4yb.cn/2021/02/15/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/","excerpt":"使用JavaScript实现链表以及双向链表","text":"使用JavaScript实现链表以及双向链表 链表结构​ 链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向后一个节点。如图： 链表对比数组 优点 链表内存空间不是必须是连续的，可以充分利用计算机内存空间。 链表不必再创建时就设定大小，并且大小可以无限的延申下去。 链表在插入和删除数据时，时间复杂度可以达到O(1)，效率相对数组高很多 缺点 链表访问任何一个位置的元素时，都学要从头开始访问，无法通过下标直接访问元素 链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//封装链表function LinkedList()&#123; //封装Node类作为节点 function Node(data)&#123; this.data = data; this.next = null; &#125; //属性 this.length = 0; this.head = null; //方法 //向链表尾部添加一个新的项 LinkedList.prototype.apend = function(data)&#123; let newNode = new Node(data); if(this.head == null)&#123; this.head = newNode; &#125;else&#123; let current = this.head; while(current.next)&#123; current = current.next; &#125; current.next = newNode; &#125; this.length++; &#125; //向链表的特定位置插入一个新的项 LinkedList.prototype.insert = function (positon, data) &#123; //越界判断 if(positon &lt; 0 || positon &gt; this.length)&#123; return false; &#125;else&#123; let newNode = new Node(data); //判断链表是否为空 if(!this.head)&#123; this.head = newNode; &#125;else&#123; let current = this.head; let previous = null; if(positon == 0)&#123; newNode.next = current; this.head = newNode; &#125;else&#123; let i = 0; while(i++ &lt; positon)&#123; previous = current; current = current.next; &#125; newNode.next = current; previous.next = newNode; &#125; &#125; &#125; this.length++; &#125; //获取对应位置的元素 LinkedList.prototype.get = function (position) &#123; if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125; let current = this.head; for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; return current; &#125; //返回元素在列表中的索引，如果链表中没有该元素则返回-1 LinkedList.prototype.indexOf = function(data)&#123; let current = this.head; let index = 1; while(current)&#123; if(current.data == data)&#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125; //修改某个位置的元素 LinkedList.prototype.update = function(position, data)&#123; let current = this.get(position); current.data = data; &#125; //从链表的特定位置移除一项 LinkedList.prototype.removeAt = function(position)&#123; if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125; let previous = null; let current = this.head; let i = 1; if(position == 1)&#123; this.head = current.next; &#125;else&#123; while(i++ &lt; position)&#123; previous = current; current = current.next; &#125; previous.next = current.next; current.next = previous.next; &#125; this.length--; &#125; //从链表中移除一项 LinkedList.prototype.remove = function (data) &#123; this.removeAt(this.indexOf(data)); this.length--; &#125; //如果链表中不包含任何元素，返回true，否则返回false LinkedList.prototype.isEmpty = function()&#123; if(this.length)&#123; return false; &#125;else&#123; return true; &#125; &#125; //返回链表包含的元素个数 LinkedList.prototype.size = function()&#123; return this.length; &#125; //由于链表项使用了Node类，就需要重写继承自Javascript对象默认的toString方法，让其只输出元素的值 LinkedList.prototype.toString = function () &#123; let current = this.head; var listString = &quot;&quot;; while(current)&#123; listString += &#x27; &#x27; + current.data; current = current.next this.length++; &#125; return listString; &#125;&#125; 双向链表 单向链表 只能从头遍历到尾或者从尾遍历到头 可以轻松地到达下一个节点，但是回到前一个节点是很难地 双向链表 既可以从头遍历到尾，也可从尾遍历到头 一个节点既有向前遍历的节点，也有向后遍历的节点 每次加入或删除节点时，需要处理四个节点的引用，实现起来更加复杂 相比于单向链表，占用内存空间更大 图示： 双向链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180function DoublyLinkedList()&#123; //构建Node类 function Node(element)&#123; this.element = element; this.prev = null; this.next = null; &#125; this.head = null; this.tail = null; this.length = 0 //向链表尾部添加一个新的项 DoublyLinkedList.prototype.apend = function(element)&#123; let newNode = new Node(element); if(this.length == 0)&#123; this.head = newNode; this.tail = newNode; &#125;else&#123; this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; &#125; this.length++; &#125; //向链表的特定位置添加一个新的项 DoublyLinkedList.prototype.insert = function(position, element)&#123; let newNode = new Node(element); //越界判断 if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125;else&#123; //链表为空的情况 if (this.length == 0)&#123; this.head = newNode; this.tail = newNode; &#125;else if(position &lt; this.length/2)&#123; //插入位置为0的情况 if(position == 0)&#123; this.head.prev = newNode; newNode.next = this.head; this.head = newNode; &#125;else&#123; //插入位置为链表前半段的情况 let current = this.head; for(let i = 0; i &lt; position; i++)&#123; current = current.next; &#125; current.prev.next = newNode; newNode.prev = current.prev; current.prev = newNode; newNode.next = current; &#125; &#125;else if(position == this.length)&#123; //插入位置为尾部的情况 newNode.prev = this.tail; this.tail.next = newNode; this.tail = newNode; &#125;else&#123; //插入位置为后半段的情况 let current = this.tail; for(let i = this.length; i &gt; position; i--)&#123; current = current.prev; &#125; current.next.prev = newNode; newNode.next = current.next; current.next = newNode; newNode.prev = current; &#125; &#125; this.length++; &#125; //获取对应位置的元素 DoublyLinkedList.prototype.get = function(position) &#123; //越界判断 if(position &lt; 0 || position &gt; this.length)&#123; return false; &#125;else&#123; let current = this.head; for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; return current.element; &#125; &#125; //返回元素在链表中的索引，如果没有则返回-1 DoublyLinkedList.prototype.indexOf = function(element)&#123; let current = this.head; let index = 0; while(current) &#123; index++; if(current.element == element)&#123; return index; &#125; current = current.next; &#125; return -1; &#125; //修改某个位置的元素 DoublyLinkedList.prototype.update = function(position, newElement)&#123; //越界判断 if(position &lt;= 0 || position &gt; this.length)&#123; return false; &#125;else&#123; let current = this.head for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; current.element = newElement; return true; &#125; &#125; //从链表中的特定位置移除一项 DoublyLinkedList.prototype.removeAt = function(position)&#123; //越界判断 if(position &lt;= 0 || position &gt; this.length)&#123; return false; &#125;else&#123; let current = this.head; if(position == 1)&#123; this.head = this.head.next; this.head.prev = null; &#125;else if(position == this.length)&#123; this.tail = this.tail.prev; this.tail.next = null; &#125;else&#123; for(let i = 1; i &lt; position; i++)&#123; current = current.next; &#125; current.prev.next = current.next; current.next.prev = current.prev; &#125; &#125; this.length--; &#125; //判断链表是否为空 DoublyLinkedList.prototype.isEmpty = function()&#123; return this.length == 0; &#125; //返回链表包含的元素个数 DoublyLinkedList.prototype.size = function()&#123; return this.length; &#125; //重写toString方法 DoublyLinkedList.prototype.toString = function () &#123; let newString = &#x27;&#x27;; let current = this.head; while(current)&#123; newString += current.element + &#x27; &#x27;; current = current.next; &#125; return newString; &#125; //返回正向遍历的节点字符串形式 DoublyLinkedList.prototype.forwardString = function () &#123; return this.toString(); &#125; //返回反向遍历的节点字符串形式 DoublyLinkedList.prototype.reserveString = function()&#123; let newString = &#x27;&#x27;; let current = this.tail; while(current)&#123; newString += current.element + &#x27; &#x27;; current = current.prev; &#125; return newString; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"JavaScript实现队列","slug":"JavaScript实现队列","date":"2021-02-13T01:22:14.000Z","updated":"2021-02-13T11:13:23.808Z","comments":true,"path":"2021/02/13/JavaScript实现队列/","link":"","permalink":"https://ez4yb.cn/2021/02/13/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"基于JavaScript的数组实现队列以及优先级队列","text":"基于JavaScript的数组实现队列以及优先级队列 队列结构​ 就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出(FIFO)形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。 图示 队列常用操作 enqueue(element)将元素加入队列 dequeue()把队列的前端元素删除,并返回被移除的元素 front()查看队列的前端元素 isEmpty()查看队列是否为空 size()查看队列元素的个数 toString()返回队列字符串 队列实现1234567891011121314151617181920212223242526272829303132333435363738function Queue()&#123; //属性 this.items = []; //方法 //将元素加入队列 Queue.prototype.enqueue = function(element)&#123; this.items.push(element); &#125; //把队列的前端元素删除，并返回被移除的元素 Queue.prototype.dequeue = function()&#123; return dequeue.shift(); &#125; //查看队列的前端元素 Queue.prototype.front = function()&#123; return this.items[0]; &#125; //查看队列是否为空 Queue.prototype.isEmpty = function()&#123; return this.items.length == 0; &#125; //查看队列的个数 Queue.prototype.size = function()&#123; return this.items.length; &#125; //返回队列的字符串 Queue.prototype.toString = function()&#123; let s = &#x27;&#x27;; for(let i = 0; i &lt; this.items.length, i++)&#123; s += this.items[i] + &#x27; &#x27;; &#125; &#125;&#125; 队列应用1击鼓传花问题：几个朋友一起玩一个游戏, 围成一圈, 开始数数, 数到某个数字的人自动淘汰，最后剩下的这个人会获得胜利, 请问最后剩下的是原来在哪一个位置上的人? 实现： 12345678910111213141516function passGame(nameList, num)&#123; //创建一个队列 let queue = new Queue(); //把名单放入队列 for(let i = 0; i &lt;nameList.length; i++)&#123; queue.enqueue(nameList[i]); &#125; //循环淘汰 while(queue.size() &gt; 1)&#123; for(let i = 0; i &lt; num - 1; i++)&#123; queue.enqueue(queue.dequeue()); &#125; queue.dequeue(); &#125; return nameList.indexOf(queue.dequeue());&#125; 优先级队列顾名思义，优先级队列即元素的排列顺序与优先级有关的队列，实现优先级队列主要又两方面需要考虑： 封装元素和优先级放在一起（可以封装一个新的构造函数） 添加元素时，将当前元素的优先级和队列中已经存在元素的优先级进行比较，以获得自己正确的位置。 优先级队列实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 //优先级队列 function PriorityQueue()&#123; function QueueElement(element, priority)&#123; this.element = element; this.priority = priority; &#125; this.items = []; PriorityQueue.prototype.dequeue = function()&#123; return this.items.shift(); &#125; //查看队列的前端元素 PriorityQueue.prototype.front = function()&#123; return this.items[0]; &#125; //查看队列是否为空 PriorityQueue.prototype.isEmpty = function()&#123; return this.items.length == 0; &#125; //查看队列元素的个数 PriorityQueue.prototype.size = function()&#123; return this.items.length; &#125; //返回队列字符串 PriorityQueue.prototype.toString = function()&#123; var s = &#x27;&#x27;; for(let i = 0; i &lt; this.items.length; i++)&#123; s += this.items[i].element + &#x27;-&#x27; + this.items[i].priority + &#x27; &#x27;; &#125; return s; &#125; //插入元素 PriorityQueue.prototype.enqueue = function (element, priority) &#123; var queueElement = new QueueElement(element, priority); if(this.items.length == 0)&#123; this.items.push(queueElement) &#125;else&#123; var added = false; for(let i = 0; i &lt; this.items.length; i++)&#123; if(queueElement.priority &lt;= this.items[i].priority)&#123; this.items.splice(i ,0 , queueElement); added = true; break; &#125; &#125; //遍历完元素，优先级都大于新插入元素，则把其放在最后 if(!added)&#123; this.items.push(queueElement); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌S"},{"title":"JavaScript实现栈","slug":"JavaScript实现栈","date":"2021-02-09T14:34:46.000Z","updated":"2021-02-11T03:35:11.433Z","comments":true,"path":"2021/02/09/JavaScript实现栈/","link":"","permalink":"https://ez4yb.cn/2021/02/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88/","excerpt":"使用JavaScriot实现栈结构（数组方式）","text":"使用JavaScriot实现栈结构（数组方式） 栈结构栈是一种“运算受限”的线性表，其特点为： LIFO（last in first out），即后入栈的元素，将会先弹出栈空间，类似把很多碟子垒在一起，后放上去的必须先拿出来 如图所示： 向一个栈插入新元素又称作进栈，入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 栈结构常见操作 push(element): 添加一个新元素到栈顶位置. pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回true，否则返回false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。这个方法和数组的length属性很类似。 栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//创建栈function Stack()&#123; //栈中的属性 this.items = []; //栈中的方法 //添加一个新元素到栈顶位置 Stack.prototype.push = function(element)&#123; //借用数组的push()方法 this.items.push(element); &#125; //移除栈顶的元素，同时返回被移除的元素 Stack.prototype.pop = function()&#123; //借用数组的pop()方法 return this.items.pop(); &#125; //返回栈顶的元素，不对栈做任何修改 Stack.prototype.peek = function()&#123; return this.items[this.items.length - 1] &#125; //如果栈里没有任何元素就返回true，否则返回false Stack.prototype.isEmpty = function()&#123; return this.items.length == 0; &#125; //移除栈里的所有元素 Stack.prototype.clear = function()&#123; this.items = []; //也可以通过多次调用pop() &#125; //返回栈里的元素个数 Stack.prototype.size = function()&#123; return this.items.length; &#125; //重写toString方法 Stack.prototype.size = function()&#123; let newString = &#x27;&#x27;; for(let i = 0; i &lt; this.items.length; i++)&#123; s += this.items[i] + &#x27; &#x27;; &#125; return newString; &#125;&#125; 栈的应用十进制转化为二进制12345678910111213141516//十进制转化为二进制（decimal to binary)function dec2bin(decNumber)&#123; let stack = new Stack(); let decNum = decNumber; while(decNum)&#123; //把decNum除以2的余数压入栈 stack.push(decNum % 2); //更新decNum为其除以2向下取整的结果 decNum = Math.floor(decNum/2); &#125; let binString = &#x27;&#x27;; while(!stack.isEmpty())&#123; binString += stack.pop(); &#125; return binString;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"袁斌"},{"title":"Git语法总结","slug":"Git常用指令总结","date":"2021-01-29T16:00:00.000Z","updated":"2021-04-16T14:15:05.581Z","comments":true,"path":"2021/01/30/Git常用指令总结/","link":"","permalink":"https://ez4yb.cn/2021/01/30/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"​ 以一张思维导图的形式对Git常用指令做个概括","text":"​ 以一张思维导图的形式对Git常用指令做个概括 基础 补充 git add. 提交被修改和新建的文件,但不包括被删除的文件 git add -u更新所有被修改的文件。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://ez4yb.cn/tags/Git/"}],"author":"袁斌"},{"title":"Markdown语法总结","slug":"markdown常用语法总结","date":"2021-01-28T16:00:00.000Z","updated":"2021-03-31T10:52:54.638Z","comments":true,"path":"2021/01/29/markdown常用语法总结/","link":"","permalink":"https://ez4yb.cn/2021/01/29/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"​ ​ 借用WIki的简介：Markdown 是一种轻量级标记语言。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。","text":"​ ​ 借用WIki的简介：Markdown 是一种轻量级标记语言。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。 标题markdown标题可以用# + 文本的格式表示，#越多，标题级别越低。 123## 二级标题##### 五级标题 效果： 二级标题五级标题 同时由于markdown支持html语法，所以也可以用h标签来写标题 123&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h5&gt;五级标题&lt;/h5&gt; 效果 我是二级标题 我是五级标题 字体markdown本身的语法只支持粗，斜字体 1234567891011*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___ 效果： 斜体 斜体 粗体 粗体 粗斜体 粗斜体 同样的，由于支持html语法，我们也可以通过内嵌html来实现修改字体，字号，颜色 字体的设置使用face。 12&lt;font face=&quot;微软雅黑&quot; &gt;微软雅黑&lt;/font&gt;&lt;font face=&quot;华文彩云&quot; &gt;华文彩云&lt;/font&gt; 字号的设置使用size，字号数值可设为1~7，浏览器默认为3。 12&lt;font size=2 &gt;2号字&lt;/font&gt;&lt;font size=5 &gt;5号字&lt;/font&gt; 字体颜色的设置使用color 123&lt;font color=#FF000 &gt;红色&lt;/font&gt;&lt;font color=rgb(136,136,136) &gt;绿色&lt;/font&gt;&lt;font color=blue &gt;蓝色&lt;/font&gt; 效果 微软雅黑华文彩云 2号字5号字 红色绿色蓝色 分隔线可以用***或者—来生成分隔线 123***--- 效果： 特殊标识 下划线 &lt;u&gt;下划线&lt;/u&gt; 效果： 下划线 删除线 ~~删除线~~ 效果： 删除线 脚注 123我是一句话[^我是一个脚注][^我是一个脚注]: 我是脚注的内容（放在文末） 效果： 我是一句话^我是一个脚注 转义如果要显示字符本来的内容，需在前面加上反斜杠进行转义 12**文本加粗** \\*\\* 正常显示星号 \\*\\* 效果 文本加粗 ** 正常显示星号 ** 列表 无序列表 123* 无序列表- 无序列表+ 无序列表 效果： 无序列表 无序列表 无序列表 有序列表 1231. 第一列2. 第二列3. 第三列 效果： 第一列 第二列 第三列 表格注意使用—来划分表头和内容 1234|表头|表头|表头||---|---|---||内容|内容|内容||内容|内容|内容| 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 区块使用 &gt; 来来创建区块，也可以在区块中再次使用 &gt; 实现区块嵌套 123&gt;第一层&gt;&gt;第二层&gt;&gt;&gt;第三层 效果： 第一层 第二层 第三层 代码 指定语言的代码区块 123456789​```cint i = 1;print(i);​```​```javascriptlet i = 1;console.log(i);​``` 效果 12int i = 1;print(i); 12let i = 1;console.log(i); 不指定语言的代码片段 1`console.log(1)`是一个代码片段 效果: console.log(1)是一个代码片段 链接 链接使用方法如下 1这是一个链接[百度](http://baidu.com) 效果： 这是一个链接百度 也可以直接使用链接地址 1&lt;http://baidu.com&gt; 效果： http://baidu.com 还可以通过变量来设置一个链接，变量赋值在文档末尾进行 1这个链接用1来做变量[百度][1] 效果： 这个链接用1来做变量百度 图片Markdown 图片语法格式如下： 123![一只猫](markdown常用语法总结/cat.jpg)![一只猫](markdown常用语法总结/cat.jpg &quot;猫&quot;) 效果： Markdown 还没有办法指定图片的高度与宽度，但是可以使用 标签来达到目的。 1&lt;img src = &quot;cat.jpg&quot;, width = 10%&gt; 效果： 其他除了这些，还可以用markdown实现流程图，甘特图的绘制，以及利用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式的方式在编辑器插入数学公式。但是鉴于根本用不到，故不再赘述。 补充(不定期更新) 今天发现markdown无法通过tab或空格实现完美的首行缩进，故采用在首行输入两个&amp;emsp;来实现完美的中文缩进两格： 1&amp;emsp;&amp;emsp;我的名字叫吉良吉影，33岁。住在杜王町东北部的别墅区一带，未婚。我在龟友连锁店服务。每天都要加班到晚上8点才能回家。我不抽烟，酒仅止于浅尝。晚上11点睡，每天要睡足8个小时。睡前，我一定喝一杯温牛奶，然后做20分钟的放松操，上了床，马上熟睡。一觉到天亮，决不把疲劳和压力，留到第二天。医生都说我很正常 效果： &emsp;&emsp;我的名字叫吉良吉影，33岁。住在杜王町东北部的别墅区一带，未婚。我在龟友连锁店服务。每天都要加班到晚上8点才能回家。我不抽烟，酒仅止于浅尝。晚上11点睡，每天要睡足8个小时。睡前，我一定喝一杯温牛奶，然后做20分钟的放松操，上了床，马上熟睡。一觉到天亮，决不把疲劳和压力，留到第二天。医生都说我很正常","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://ez4yb.cn/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://ez4yb.cn/tags/Typora/"}],"author":"袁斌"}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ez4yb.cn/tags/JavaScript/"},{"name":"javascipt","slug":"javascipt","permalink":"https://ez4yb.cn/tags/javascipt/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://ez4yb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"https://ez4yb.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"CSS","slug":"CSS","permalink":"https://ez4yb.cn/tags/CSS/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ez4yb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端性能","slug":"前端性能","permalink":"https://ez4yb.cn/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"},{"name":"html","slug":"html","permalink":"https://ez4yb.cn/tags/html/"},{"name":"Git","slug":"Git","permalink":"https://ez4yb.cn/tags/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ez4yb.cn/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://ez4yb.cn/tags/Typora/"}]}